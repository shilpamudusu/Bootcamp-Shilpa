{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/observable/observable.mjs"],"sourcesContent":["/** @public */ function isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\n/** @public */ function observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return operations.reduce(pipeReducer, self);\n        }\n    };\n    return self;\n}\nfunction pipeReducer(prev, fn) {\n    return fn(prev);\n}\n/** @internal */ function observableToPromise(observable) {\n    const ac = new AbortController();\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            obs$.unsubscribe();\n        }\n        ac.signal.addEventListener('abort', ()=>{\n            reject(ac.signal.reason);\n        });\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                reject(data);\n            },\n            complete () {\n                ac.abort();\n                onDone();\n            }\n        });\n    });\n    return promise;\n}\n/**\n * @internal\n */ function observableToReadableStream(observable, signal) {\n    let unsub = null;\n    const onAbort = ()=>{\n        unsub?.unsubscribe();\n        unsub = null;\n        signal.removeEventListener('abort', onAbort);\n    };\n    return new ReadableStream({\n        start (controller) {\n            unsub = observable.subscribe({\n                next (data) {\n                    controller.enqueue({\n                        ok: true,\n                        value: data\n                    });\n                },\n                error (error) {\n                    controller.enqueue({\n                        ok: false,\n                        error\n                    });\n                    controller.close();\n                },\n                complete () {\n                    controller.close();\n                }\n            });\n            if (signal.aborted) {\n                onAbort();\n            } else {\n                signal.addEventListener('abort', onAbort, {\n                    once: true\n                });\n            }\n        },\n        cancel () {\n            onAbort();\n        }\n    });\n}\n/** @internal */ function observableToAsyncIterable(observable, signal) {\n    const stream = observableToReadableStream(observable, signal);\n    const reader = stream.getReader();\n    const iterator = {\n        async next () {\n            const value = await reader.read();\n            if (value.done) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            const { value: result } = value;\n            if (!result.ok) {\n                throw result.error;\n            }\n            return {\n                value: result.value,\n                done: false\n            };\n        },\n        async return () {\n            await reader.cancel();\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n    };\n    return {\n        [Symbol.asyncIterator] () {\n            return iterator;\n        }\n    };\n}\n\nexport { isObservable, observable, observableToAsyncIterable, observableToPromise };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/observable/operators.mjs"],"sourcesContent":["import { observable } from './observable.mjs';\n\nfunction map(project) {\n    return (source)=>{\n        return observable((destination)=>{\n            let index = 0;\n            const subscription = source.subscribe({\n                next (value) {\n                    destination.next(project(value, index++));\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n            return subscription;\n        });\n    };\n}\nfunction share(_opts) {\n    return (source)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = source.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return observable((subscriber)=>{\n            refCount++;\n            observers.push(subscriber);\n            startIfNeeded();\n            return {\n                unsubscribe () {\n                    refCount--;\n                    resetIfNeeded();\n                    const index = observers.findIndex((v)=>v === subscriber);\n                    if (index > -1) {\n                        observers.splice(index, 1);\n                    }\n                }\n            };\n        });\n    };\n}\nfunction tap(observer) {\n    return (source)=>{\n        return observable((destination)=>{\n            return source.subscribe({\n                next (value) {\n                    observer.next?.(value);\n                    destination.next(value);\n                },\n                error (error) {\n                    observer.error?.(error);\n                    destination.error(error);\n                },\n                complete () {\n                    observer.complete?.();\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b)=>a === b) {\n    return (source)=>{\n        return observable((destination)=>{\n            let lastValue = distinctUnsetMarker;\n            return source.subscribe({\n                next (value) {\n                    if (lastValue !== distinctUnsetMarker && compare(lastValue, value)) {\n                        return;\n                    }\n                    lastValue = value;\n                    destination.next(value);\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\nconst isDeepEqual = (a, b)=>{\n    if (a === b) {\n        return true;\n    }\n    const bothAreObjects = a && b && typeof a === 'object' && typeof b === 'object';\n    return !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v])=>isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n    return distinctUntilChanged(isDeepEqual);\n}\n\nexport { distinctUntilChanged, distinctUntilDeepChanged, map, share, tap };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 333, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/observable/behaviorSubject.mjs"],"sourcesContent":["import { observable } from './observable.mjs';\n\n/**\n * @internal\n * An observable that maintains and provides a \"current value\" to subscribers\n * @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n */ function behaviorSubject(initialValue) {\n    let value = initialValue;\n    const observerList = [];\n    const addObserver = (observer)=>{\n        if (value !== undefined) {\n            observer.next(value);\n        }\n        observerList.push(observer);\n    };\n    const removeObserver = (observer)=>{\n        observerList.splice(observerList.indexOf(observer), 1);\n    };\n    const obs = observable((observer)=>{\n        addObserver(observer);\n        return ()=>{\n            removeObserver(observer);\n        };\n    });\n    obs.next = (nextValue)=>{\n        if (value === nextValue) {\n            return;\n        }\n        value = nextValue;\n        for (const observer of observerList){\n            observer.next(nextValue);\n        }\n    };\n    obs.get = ()=>value;\n    return obs;\n}\n\nexport { behaviorSubject };\n"],"names":[],"mappings":";;;AAAA;;AAEA;;;;CAIC,GAAG,SAAS,gBAAgB,YAAY;IACrC,IAAI,QAAQ;IACZ,MAAM,eAAe,EAAE;IACvB,MAAM,cAAc,CAAC;QACjB,IAAI,UAAU,WAAW;YACrB,SAAS,IAAI,CAAC;QAClB;QACA,aAAa,IAAI,CAAC;IACtB;IACA,MAAM,iBAAiB,CAAC;QACpB,aAAa,MAAM,CAAC,aAAa,OAAO,CAAC,WAAW;IACxD;IACA,MAAM,MAAM,CAAA,GAAA,iKAAA,CAAA,aAAU,AAAD,EAAE,CAAC;QACpB,YAAY;QACZ,OAAO;YACH,eAAe;QACnB;IACJ;IACA,IAAI,IAAI,GAAG,CAAC;QACR,IAAI,UAAU,WAAW;YACrB;QACJ;QACA,QAAQ;QACR,KAAK,MAAM,YAAY,aAAa;YAChC,SAAS,IAAI,CAAC;QAClB;IACJ;IACA,IAAI,GAAG,GAAG,IAAI;IACd,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 400, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/createProxy.mjs"],"sourcesContent":["const noop = ()=>{\n// noop\n};\nconst freezeIfAvailable = (obj)=>{\n    if (Object.freeze) {\n        Object.freeze(obj);\n    }\n};\nfunction createInnerProxy(callback, path, memo) {\n    var _memo, _cacheKey;\n    const cacheKey = path.join('.');\n    (_memo = memo)[_cacheKey = cacheKey] ?? (_memo[_cacheKey] = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ], memo);\n        },\n        apply (_1, _2, args) {\n            const lastOfPath = path[path.length - 1];\n            let opts = {\n                args,\n                path\n            };\n            // special handling for e.g. `trpc.hello.call(this, 'there')` and `trpc.hello.apply(this, ['there'])\n            if (lastOfPath === 'call') {\n                opts = {\n                    args: args.length >= 2 ? [\n                        args[1]\n                    ] : [],\n                    path: path.slice(0, -1)\n                };\n            } else if (lastOfPath === 'apply') {\n                opts = {\n                    args: args.length >= 2 ? args[1] : [],\n                    path: path.slice(0, -1)\n                };\n            }\n            freezeIfAvailable(opts.args);\n            freezeIfAvailable(opts.path);\n            return callback(opts);\n        }\n    }));\n    return memo[cacheKey];\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, [], Object.create(null));\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { createFlatProxy, createRecursiveProxy };\n"],"names":[],"mappings":";;;;AAAA,MAAM,OAAO;AACb,OAAO;AACP;AACA,MAAM,oBAAoB,CAAC;IACvB,IAAI,OAAO,MAAM,EAAE;QACf,OAAO,MAAM,CAAC;IAClB;AACJ;AACA,SAAS,iBAAiB,QAAQ,EAAE,IAAI,EAAE,IAAI;IAC1C,IAAI,OAAO;IACX,MAAM,WAAW,KAAK,IAAI,CAAC;IAC3B,CAAC,QAAQ,IAAI,CAAC,CAAC,YAAY,SAAS,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,IAAI,MAAM,MAAM;QACxE,KAAK,IAAI,EAAE,GAAG;YACV,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ;gBAC3C,wDAAwD;gBACxD,wDAAwD;gBACxD,OAAO;YACX;YACA,OAAO,iBAAiB,UAAU;mBAC3B;gBACH;aACH,EAAE;QACP;QACA,OAAO,EAAE,EAAE,EAAE,EAAE,IAAI;YACf,MAAM,aAAa,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE;YACxC,IAAI,OAAO;gBACP;gBACA;YACJ;YACA,oGAAoG;YACpG,IAAI,eAAe,QAAQ;gBACvB,OAAO;oBACH,MAAM,KAAK,MAAM,IAAI,IAAI;wBACrB,IAAI,CAAC,EAAE;qBACV,GAAG,EAAE;oBACN,MAAM,KAAK,KAAK,CAAC,GAAG,CAAC;gBACzB;YACJ,OAAO,IAAI,eAAe,SAAS;gBAC/B,OAAO;oBACH,MAAM,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,EAAE,GAAG,EAAE;oBACrC,MAAM,KAAK,KAAK,CAAC,GAAG,CAAC;gBACzB;YACJ;YACA,kBAAkB,KAAK,IAAI;YAC3B,kBAAkB,KAAK,IAAI;YAC3B,OAAO,SAAS;QACpB;IACJ,EAAE;IACF,OAAO,IAAI,CAAC,SAAS;AACzB;AACA;;;;CAIC,GAAG,MAAM,uBAAuB,CAAC,WAAW,iBAAiB,UAAU,EAAE,EAAE,OAAO,MAAM,CAAC;AAC1F;;;;CAIC,GAAG,MAAM,kBAAkB,CAAC;IACzB,OAAO,IAAI,MAAM,MAAM;QACnB,KAAK,IAAI,EAAE,IAAI;YACX,IAAI,OAAO,SAAS,YAAY,SAAS,QAAQ;gBAC7C,wDAAwD;gBACxD,wDAAwD;gBACxD,OAAO;YACX;YACA,OAAO,SAAS;QACpB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 482, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/error/formatter.mjs"],"sourcesContent":["const defaultFormatter = ({ shape })=>{\n    return shape;\n};\n\nexport { defaultFormatter };\n"],"names":[],"mappings":";;;AAAA,MAAM,mBAAmB,CAAC,EAAE,KAAK,EAAE;IAC/B,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/rpc/codes.mjs"],"sourcesContent":["// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    // Internal JSON-RPC error\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    BAD_GATEWAY: -32603,\n    SERVICE_UNAVAILABLE: -32603,\n    GATEWAY_TIMEOUT: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNSUPPORTED_MEDIA_TYPE: -32015,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\n// pure\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n    [-32700]: 'PARSE_ERROR',\n    [-32600]: 'BAD_REQUEST',\n    [-32603]: 'INTERNAL_SERVER_ERROR',\n    [-32001]: 'UNAUTHORIZED',\n    [-32003]: 'FORBIDDEN',\n    [-32004]: 'NOT_FOUND',\n    [-32005]: 'METHOD_NOT_SUPPORTED',\n    [-32008]: 'TIMEOUT',\n    [-32009]: 'CONFLICT',\n    [-32012]: 'PRECONDITION_FAILED',\n    [-32013]: 'PAYLOAD_TOO_LARGE',\n    [-32015]: 'UNSUPPORTED_MEDIA_TYPE',\n    [-32022]: 'UNPROCESSABLE_CONTENT',\n    [-32029]: 'TOO_MANY_REQUESTS',\n    [-32099]: 'CLIENT_CLOSED_REQUEST'\n};\n\nexport { TRPC_ERROR_CODES_BY_KEY, TRPC_ERROR_CODES_BY_NUMBER };\n"],"names":[],"mappings":"AAAA,mDAAmD;AACnD;;;;;CAKC;;;;AAAG,MAAM,0BAA0B;IAChC;;;GAGD,GAAG,aAAa,CAAC;IAChB;;GAED,GAAG,aAAa,CAAC;IAChB,0BAA0B;IAC1B,uBAAuB,CAAC;IACxB,iBAAiB,CAAC;IAClB,aAAa,CAAC;IACd,qBAAqB,CAAC;IACtB,iBAAiB,CAAC;IAClB,iCAAiC;IACjC,cAAc,CAAC;IACf,WAAW,CAAC;IACZ,WAAW,CAAC;IACZ,sBAAsB,CAAC;IACvB,SAAS,CAAC;IACV,UAAU,CAAC;IACX,qBAAqB,CAAC;IACtB,mBAAmB,CAAC;IACpB,wBAAwB,CAAC;IACzB,uBAAuB,CAAC;IACxB,mBAAmB,CAAC;IACpB,uBAAuB,CAAC;AAC5B;AACA,OAAO;AACP,MAAM,6BAA6B;IAC/B,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;IACV,CAAC,CAAC,MAAM,EAAE;AACd","ignoreList":[0]}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/utils.mjs"],"sourcesContent":["/** @internal */ const unsetMarker = Symbol();\n/**\n * Ensures there are no duplicate keys when building a procedure.\n * @internal\n */ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs){\n        for(const key in overrides){\n            if (key in newObj && newObj[key] !== overrides[key]) {\n                throw new Error(`Duplicate key ${key}`);\n            }\n            newObj[key] = overrides[key];\n        }\n    }\n    return newObj;\n}\n/**\n * Check that value is object\n * @internal\n */ function isObject(value) {\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\nfunction isFunction(fn) {\n    return typeof fn === 'function';\n}\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === 'function' && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n    return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n * Run an IIFE\n */ const run = (fn)=>fn();\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nfunction identity(it) {\n    return it;\n}\n/**\n * Generic runtime assertion function. Throws, if the condition is not `true`.\n *\n * Can be used as a slightly less dangerous variant of type assertions. Code\n * mistakes would be revealed at runtime then (hopefully during testing).\n */ function assert(condition, msg = 'no additional info') {\n    if (!condition) {\n        throw new Error(`AssertionError: ${msg}`);\n    }\n}\nfunction sleep(ms = 0) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\n * Ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */ function abortSignalsAnyPonyfill(signals) {\n    if (typeof AbortSignal.any === 'function') {\n        return AbortSignal.any(signals);\n    }\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal.aborted) {\n            trigger();\n            break;\n        }\n        signal.addEventListener('abort', trigger, {\n            once: true\n        });\n    }\n    return ac.signal;\n    function trigger() {\n        ac.abort();\n        for (const signal of signals){\n            signal.removeEventListener('abort', trigger);\n        }\n    }\n}\n\nexport { abortSignalsAnyPonyfill, assert, identity, isAsyncIterable, isFunction, isObject, mergeWithoutOverrides, noop, omitPrototype, run, sleep, unsetMarker };\n"],"names":[],"mappings":"AAAA,cAAc;;;;;;;;;;;;;;AAAG,MAAM,cAAc;AACrC;;;CAGC,GAAG,SAAS,sBAAsB,IAAI,EAAE,GAAG,IAAI;IAC5C,MAAM,SAAS,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO;IAClD,KAAK,MAAM,aAAa,KAAK;QACzB,IAAI,MAAM,OAAO,UAAU;YACvB,IAAI,OAAO,UAAU,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,EAAE;gBACjD,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,KAAK;YAC1C;YACA,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI;QAChC;IACJ;IACA,OAAO;AACX;AACA;;;CAGC,GAAG,SAAS,SAAS,KAAK;IACvB,OAAO,CAAC,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,UAAU,OAAO,UAAU;AAChE;AACA,SAAS,WAAW,EAAE;IAClB,OAAO,OAAO,OAAO;AACzB;AACA;;;CAGC,GAAG,SAAS,cAAc,GAAG;IAC1B,OAAO,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO;AAC9C;AACA,MAAM,0BAA0B,OAAO,WAAW,cAAc,CAAC,CAAC,OAAO,aAAa;AACtF,SAAS,gBAAgB,KAAK;IAC1B,OAAO,2BAA2B,SAAS,UAAU,OAAO,aAAa,IAAI;AACjF;AACA;;CAEC,GAAG,MAAM,MAAM,CAAC,KAAK;AACtB,gEAAgE;AAChE,SAAS,QAAQ;AACjB,SAAS,SAAS,EAAE;IAChB,OAAO;AACX;AACA;;;;;CAKC,GAAG,SAAS,OAAO,SAAS,EAAE,MAAM,oBAAoB;IACrD,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,KAAK;IAC5C;AACJ;AACA,SAAS,MAAM,KAAK,CAAC;IACjB,OAAO,IAAI,QAAQ,CAAC,MAAM,WAAW,KAAK;AAC9C;AACA;;;CAGC,GAAG,SAAS,wBAAwB,OAAO;IACxC,IAAI,OAAO,YAAY,GAAG,KAAK,YAAY;QACvC,OAAO,YAAY,GAAG,CAAC;IAC3B;IACA,MAAM,KAAK,IAAI;IACf,KAAK,MAAM,UAAU,QAAQ;QACzB,IAAI,OAAO,OAAO,EAAE;YAChB;YACA;QACJ;QACA,OAAO,gBAAgB,CAAC,SAAS,SAAS;YACtC,MAAM;QACV;IACJ;IACA,OAAO,GAAG,MAAM;;IAChB,SAAS;QACL,GAAG,KAAK;QACR,KAAK,MAAM,UAAU,QAAQ;YACzB,OAAO,mBAAmB,CAAC,SAAS;QACxC;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 655, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 661, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/getHTTPStatusCode.mjs"],"sourcesContent":["import { TRPC_ERROR_CODES_BY_NUMBER } from '../rpc/codes.mjs';\nimport { isObject } from '../utils.mjs';\n\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n    400: 'BAD_REQUEST',\n    401: 'UNAUTHORIZED',\n    403: 'FORBIDDEN',\n    404: 'NOT_FOUND',\n    405: 'METHOD_NOT_SUPPORTED',\n    408: 'TIMEOUT',\n    409: 'CONFLICT',\n    412: 'PRECONDITION_FAILED',\n    413: 'PAYLOAD_TOO_LARGE',\n    415: 'UNSUPPORTED_MEDIA_TYPE',\n    422: 'UNPROCESSABLE_CONTENT',\n    429: 'TOO_MANY_REQUESTS',\n    499: 'CLIENT_CLOSED_REQUEST',\n    500: 'INTERNAL_SERVER_ERROR',\n    501: 'NOT_IMPLEMENTED',\n    502: 'BAD_GATEWAY',\n    503: 'SERVICE_UNAVAILABLE',\n    504: 'GATEWAY_TIMEOUT'\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getStatusKeyFromCode(code) {\n    return HTTP_CODE_TO_JSONRPC2[code] ?? 'INTERNAL_SERVER_ERROR';\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res && isObject(res.error.data)) {\n            if (typeof res.error.data?.['httpStatus'] === 'number') {\n                return res.error.data['httpStatus'];\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n\nexport { HTTP_CODE_TO_JSONRPC2, JSONRPC2_TO_HTTP_CODE, getHTTPStatusCode, getHTTPStatusCodeFromError, getStatusCodeFromKey, getStatusKeyFromCode };\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,MAAM,wBAAwB;IAC1B,aAAa;IACb,aAAa;IACb,cAAc;IACd,WAAW;IACX,WAAW;IACX,sBAAsB;IACtB,SAAS;IACT,UAAU;IACV,qBAAqB;IACrB,mBAAmB;IACnB,wBAAwB;IACxB,uBAAuB;IACvB,mBAAmB;IACnB,uBAAuB;IACvB,uBAAuB;IACvB,iBAAiB;IACjB,aAAa;IACb,qBAAqB;IACrB,iBAAiB;AACrB;AACA,MAAM,wBAAwB;IAC1B,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACT;AACA,SAAS,qBAAqB,IAAI;IAC9B,OAAO,qBAAqB,CAAC,KAAK,IAAI;AAC1C;AACA,SAAS,qBAAqB,IAAI;IAC9B,OAAO,qBAAqB,CAAC,KAAK,IAAI;AAC1C;AACA,SAAS,kBAAkB,IAAI;IAC3B,MAAM,MAAM,MAAM,OAAO,CAAC,QAAQ,OAAO;QACrC;KACH;IACD,MAAM,eAAe,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC;QAClC,IAAI,WAAW,OAAO,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,IAAI,KAAK,CAAC,IAAI,GAAG;YAC5C,IAAI,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,aAAa,KAAK,UAAU;gBACpD,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,aAAa;YACvC;YACA,MAAM,OAAO,gMAAA,CAAA,6BAA0B,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC;YACvD,OAAO,qBAAqB;QAChC;QACA,OAAO;IACX;IACA,IAAI,aAAa,IAAI,KAAK,GAAG;QACzB,OAAO;IACX;IACA,MAAM,aAAa,aAAa,MAAM,GAAG,IAAI,GAAG,KAAK;IACrD,oEAAoE;IACpE,OAAO;AACX;AACA,SAAS,2BAA2B,KAAK;IACrC,OAAO,qBAAqB,MAAM,IAAI;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 745, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 751, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/error/getErrorShape.mjs"],"sourcesContent":["import { getHTTPStatusCodeFromError } from '../http/getHTTPStatusCode.mjs';\nimport { TRPC_ERROR_CODES_BY_KEY } from '../rpc/codes.mjs';\n\n/**\n * @internal\n */ function getErrorShape(opts) {\n    const { path, error, config } = opts;\n    const { code } = opts.error;\n    const shape = {\n        message: error.message,\n        code: TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === 'string') {\n        shape.data.stack = opts.error.stack;\n    }\n    if (typeof path === 'string') {\n        shape.data.path = path;\n    }\n    return config.errorFormatter({\n        ...opts,\n        shape\n    });\n}\n\nexport { getErrorShape };\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA;;CAEC,GAAG,SAAS,cAAc,IAAI;IAC3B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG;IAChC,MAAM,EAAE,IAAI,EAAE,GAAG,KAAK,KAAK;IAC3B,MAAM,QAAQ;QACV,SAAS,MAAM,OAAO;QACtB,MAAM,gMAAA,CAAA,0BAAuB,CAAC,KAAK;QACnC,MAAM;YACF;YACA,YAAY,CAAA,GAAA,6MAAA,CAAA,6BAA0B,AAAD,EAAE;QAC3C;IACJ;IACA,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,KAAK,KAAK,UAAU;QACtD,MAAM,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK,CAAC,KAAK;IACvC;IACA,IAAI,OAAO,SAAS,UAAU;QAC1B,MAAM,IAAI,CAAC,IAAI,GAAG;IACtB;IACA,OAAO,OAAO,cAAc,CAAC;QACzB,GAAG,IAAI;QACP;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 783, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/error/TRPCError.mjs"],"sourcesContent":["import { isObject } from '../utils.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) {\n        return cause;\n    }\n    if (cause instanceof Error && cause.name === 'TRPCError') {\n        // https://github.com/trpc/trpc/pull/4848\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause\n    });\n    // Inherit stack from error\n    if (cause instanceof Error && cause.stack) {\n        trpcError.stack = cause.stack;\n    }\n    return trpcError;\n}\nclass TRPCError extends Error {\n    constructor(opts){\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = opts.message ?? cause?.message ?? opts.code;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        }), // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n        _define_property(this, \"cause\", void 0), _define_property(this, \"code\", void 0);\n        this.code = opts.code;\n        this.name = 'TRPCError';\n        if (!this.cause) {\n            // < ES2022 / < Node 16.9.0 compatability\n            this.cause = cause;\n        }\n    }\n}\n\nexport { TRPCError, getCauseFromUnknown, getTRPCErrorFromUnknown };\n"],"names":[],"mappings":";;;;;AAAA;;AAEA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAC5B,OAAO;YACP,YAAY;YACZ,cAAc;YACd,UAAU;QACd;IACJ,OAAO;QACH,GAAG,CAAC,IAAI,GAAG;IACf;IACA,OAAO;AACX;AACA,MAAM,0BAA0B;AAChC;AACA,SAAS,oBAAoB,KAAK;IAC9B,IAAI,iBAAiB,OAAO;QACxB,OAAO;IACX;IACA,MAAM,OAAO,OAAO;IACpB,IAAI,SAAS,eAAe,SAAS,cAAc,UAAU,MAAM;QAC/D,OAAO;IACX;IACA,+CAA+C;IAC/C,IAAI,SAAS,UAAU;QACnB,OAAO,IAAI,MAAM,OAAO;IAC5B;IACA,oDAAoD;IACpD,IAAI,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ;QACjB,MAAM,MAAM,IAAI;QAChB,IAAI,MAAM,OAAO,MAAM;YACnB,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI;QACzB;QACA,OAAO;IACX;IACA,OAAO;AACX;AACA,SAAS,wBAAwB,KAAK;IAClC,IAAI,iBAAiB,WAAW;QAC5B,OAAO;IACX;IACA,IAAI,iBAAiB,SAAS,MAAM,IAAI,KAAK,aAAa;QACtD,yCAAyC;QACzC,OAAO;IACX;IACA,MAAM,YAAY,IAAI,UAAU;QAC5B,MAAM;QACN;IACJ;IACA,2BAA2B;IAC3B,IAAI,iBAAiB,SAAS,MAAM,KAAK,EAAE;QACvC,UAAU,KAAK,GAAG,MAAM,KAAK;IACjC;IACA,OAAO;AACX;AACA,MAAM,kBAAkB;IACpB,YAAY,IAAI,CAAC;QACb,MAAM,QAAQ,oBAAoB,KAAK,KAAK;QAC5C,MAAM,UAAU,KAAK,OAAO,IAAI,OAAO,WAAW,KAAK,IAAI;QAC3D,6DAA6D;QAC7D,0DAA0D;QAC1D,KAAK,CAAC,SAAS;YACX;QACJ,IACA,oKAAoK;QACpK,iBAAiB,IAAI,EAAE,SAAS,KAAK,IAAI,iBAAiB,IAAI,EAAE,QAAQ,KAAK;QAC7E,IAAI,CAAC,IAAI,GAAG,KAAK,IAAI;QACrB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACb,yCAAyC;YACzC,IAAI,CAAC,KAAK,GAAG;QACjB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 870, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 876, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/parseConnectionParams.mjs"],"sourcesContent":["import { TRPCError } from '../error/TRPCError.mjs';\nimport { isObject } from '../utils.mjs';\n\nfunction parseConnectionParamsFromUnknown(parsed) {\n    try {\n        if (parsed === null) {\n            return null;\n        }\n        if (!isObject(parsed)) {\n            throw new Error('Expected object');\n        }\n        const nonStringValues = Object.entries(parsed).filter(([_key, value])=>typeof value !== 'string');\n        if (nonStringValues.length > 0) {\n            throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value])=>`${key}: ${typeof value}`).join(', ')}`);\n        }\n        return parsed;\n    } catch (cause) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            message: 'Invalid connection params shape',\n            cause\n        });\n    }\n}\nfunction parseConnectionParamsFromString(str) {\n    let parsed;\n    try {\n        parsed = JSON.parse(str);\n    } catch (cause) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            message: 'Not JSON-parsable query params',\n            cause\n        });\n    }\n    return parseConnectionParamsFromUnknown(parsed);\n}\n\nexport { parseConnectionParamsFromString, parseConnectionParamsFromUnknown };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,SAAS,iCAAiC,MAAM;IAC5C,IAAI;QACA,IAAI,WAAW,MAAM;YACjB,OAAO;QACX;QACA,IAAI,CAAC,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,SAAS;YACnB,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,kBAAkB,OAAO,OAAO,CAAC,QAAQ,MAAM,CAAC,CAAC,CAAC,MAAM,MAAM,GAAG,OAAO,UAAU;QACxF,IAAI,gBAAgB,MAAM,GAAG,GAAG;YAC5B,MAAM,IAAI,MAAM,CAAC,mDAAmD,EAAE,gBAAgB,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,GAAG,GAAG,IAAI,EAAE,EAAE,OAAO,OAAO,EAAE,IAAI,CAAC,OAAO;QACrJ;QACA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,MAAM,IAAI,sMAAA,CAAA,YAAS,CAAC;YAChB,MAAM;YACN,SAAS;YACT;QACJ;IACJ;AACJ;AACA,SAAS,gCAAgC,GAAG;IACxC,IAAI;IACJ,IAAI;QACA,SAAS,KAAK,KAAK,CAAC;IACxB,EAAE,OAAO,OAAO;QACZ,MAAM,IAAI,sMAAA,CAAA,YAAS,CAAC;YAChB,MAAM;YACN,SAAS;YACT;QACJ;IACJ;IACA,OAAO,iCAAiC;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 919, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/contentType.mjs"],"sourcesContent":["import { TRPCError } from '../error/TRPCError.mjs';\nimport { isObject, unsetMarker } from '../utils.mjs';\nimport { parseConnectionParamsFromString } from './parseConnectionParams.mjs';\n\n/**\n * Memoize a function that takes no arguments\n * @internal\n */ function memo(fn) {\n    let promise = null;\n    let value = unsetMarker;\n    return {\n        /**\n     * Lazily read the value\n     */ read: async ()=>{\n            if (value !== unsetMarker) {\n                return value;\n            }\n            if (promise === null) {\n                // dedupes promises and catches errors\n                promise = fn().catch((cause)=>{\n                    if (cause instanceof TRPCError) {\n                        throw cause;\n                    }\n                    throw new TRPCError({\n                        code: 'BAD_REQUEST',\n                        message: cause instanceof Error ? cause.message : 'Invalid input',\n                        cause\n                    });\n                });\n            }\n            value = await promise;\n            promise = null;\n            return value;\n        },\n        /**\n     * Get an already stored result\n     */ result: ()=>{\n            return value !== unsetMarker ? value : undefined;\n        }\n    };\n}\nconst jsonContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get('content-type')?.startsWith('application/json');\n    },\n    parse (opts) {\n        const { req } = opts;\n        const isBatchCall = opts.searchParams.get('batch') === '1';\n        const paths = isBatchCall ? opts.path.split(',') : [\n            opts.path\n        ];\n        const getInputs = memo(async ()=>{\n            let inputs = undefined;\n            if (req.method === 'GET') {\n                const queryInput = opts.searchParams.get('input');\n                if (queryInput) {\n                    inputs = JSON.parse(queryInput);\n                }\n            } else {\n                inputs = await req.json();\n            }\n            if (inputs === undefined) {\n                return {};\n            }\n            if (!isBatchCall) {\n                return {\n                    0: opts.router._def._config.transformer.input.deserialize(inputs)\n                };\n            }\n            if (!isObject(inputs)) {\n                throw new TRPCError({\n                    code: 'BAD_REQUEST',\n                    message: '\"input\" needs to be an object when doing a batch call'\n                });\n            }\n            const acc = {};\n            for (const index of paths.keys()){\n                const input = inputs[index];\n                if (input !== undefined) {\n                    acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n                }\n            }\n            return acc;\n        });\n        const calls = paths.map((path, index)=>{\n            const procedure = opts.router._def.procedures[path] ?? null;\n            return {\n                path,\n                procedure,\n                getRawInput: async ()=>{\n                    const inputs = await getInputs.read();\n                    let input = inputs[index];\n                    if (procedure?._def.type === 'subscription') {\n                        const lastEventId = opts.headers.get('last-event-id') ?? opts.searchParams.get('lastEventId') ?? opts.searchParams.get('Last-Event-Id');\n                        if (lastEventId) {\n                            if (isObject(input)) {\n                                input = {\n                                    ...input,\n                                    lastEventId: lastEventId\n                                };\n                            } else {\n                                input ?? (input = {\n                                    lastEventId: lastEventId\n                                });\n                            }\n                        }\n                    }\n                    return input;\n                },\n                result: ()=>{\n                    return getInputs.result()?.[index];\n                }\n            };\n        });\n        const types = new Set(calls.map((call)=>call.procedure?._def.type).filter(Boolean));\n        /* istanbul ignore if -- @preserve */ if (types.size > 1) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                message: `Cannot mix procedure types in call: ${Array.from(types).join(', ')}`\n            });\n        }\n        const type = types.values().next().value ?? 'unknown';\n        const connectionParamsStr = opts.searchParams.get('connectionParams');\n        const info = {\n            isBatchCall,\n            accept: req.headers.get('trpc-accept'),\n            calls,\n            type,\n            connectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n            signal: req.signal\n        };\n        return info;\n    }\n};\nconst formDataContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get('content-type')?.startsWith('multipart/form-data');\n    },\n    parse (opts) {\n        const { req } = opts;\n        if (req.method !== 'POST') {\n            throw new TRPCError({\n                code: 'METHOD_NOT_SUPPORTED',\n                message: 'Only POST requests are supported for multipart/form-data requests'\n            });\n        }\n        const getInputs = memo(async ()=>{\n            const fd = await req.formData();\n            return fd;\n        });\n        return {\n            accept: null,\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: opts.router._def.procedures[opts.path] ?? null\n                }\n            ],\n            isBatchCall: false,\n            type: 'mutation',\n            connectionParams: null,\n            signal: req.signal\n        };\n    }\n};\nconst octetStreamContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get('content-type')?.startsWith('application/octet-stream');\n    },\n    parse (opts) {\n        const { req } = opts;\n        if (req.method !== 'POST') {\n            throw new TRPCError({\n                code: 'METHOD_NOT_SUPPORTED',\n                message: 'Only POST requests are supported for application/octet-stream requests'\n            });\n        }\n        const getInputs = memo(async ()=>{\n            return req.body;\n        });\n        return {\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: opts.router._def.procedures[opts.path] ?? null\n                }\n            ],\n            isBatchCall: false,\n            accept: null,\n            type: 'mutation',\n            connectionParams: null,\n            signal: req.signal\n        };\n    }\n};\nconst handlers = [\n    jsonContentTypeHandler,\n    formDataContentTypeHandler,\n    octetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n    const handler = handlers.find((handler)=>handler.isMatch(req));\n    if (handler) {\n        return handler;\n    }\n    if (!handler && req.method === 'GET') {\n        // fallback to JSON for get requests so GET-requests can be opened in browser easily\n        return jsonContentTypeHandler;\n    }\n    throw new TRPCError({\n        code: 'UNSUPPORTED_MEDIA_TYPE',\n        message: req.headers.has('content-type') ? `Unsupported content-type \"${req.headers.get('content-type')}` : 'Missing content-type header'\n    });\n}\nfunction getRequestInfo(opts) {\n    const handler = getContentTypeHandler(opts.req);\n    return handler.parse(opts);\n}\n\nexport { getRequestInfo };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1153, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1159, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/contentTypeParsers.mjs"],"sourcesContent":["const octetInputParser = {\n    _input: null,\n    _output: null,\n    parse (input) {\n        if (input instanceof ReadableStream) {\n            return input;\n        }\n        throw new Error(`Parsed input was expected to be a ReadableStream but was: ${typeof input}`);\n    }\n};\n\nexport { octetInputParser };\n"],"names":[],"mappings":";;;AAAA,MAAM,mBAAmB;IACrB,QAAQ;IACR,SAAS;IACT,OAAO,KAAK;QACR,IAAI,iBAAiB,gBAAgB;YACjC,OAAO;QACX;QACA,MAAM,IAAI,MAAM,CAAC,0DAA0D,EAAE,OAAO,OAAO;IAC/F;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1173, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1179, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/formDataToObject.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */ const isNumberString = (str)=>/^\\d+$/.test(str);\nfunction set(obj, path, value) {\n    if (path.length > 1) {\n        const newPath = [\n            ...path\n        ];\n        const key = newPath.shift();\n        const nextKey = newPath[0];\n        if (!obj[key]) {\n            obj[key] = isNumberString(nextKey) ? [] : {};\n        } else if (Array.isArray(obj[key]) && !isNumberString(nextKey)) {\n            obj[key] = Object.fromEntries(Object.entries(obj[key]));\n        }\n        set(obj[key], newPath, value);\n        return;\n    }\n    const p = path[0];\n    if (obj[p] === undefined) {\n        obj[p] = value;\n    } else if (Array.isArray(obj[p])) {\n        obj[p].push(value);\n    } else {\n        obj[p] = [\n            obj[p],\n            value\n        ];\n    }\n}\nfunction formDataToObject(formData) {\n    const obj = {};\n    for (const [key, value] of formData.entries()){\n        const parts = key.split(/[\\.\\[\\]]/).filter(Boolean);\n        set(obj, parts, value);\n    }\n    return obj;\n}\n\nexport { formDataToObject };\n"],"names":[],"mappings":"AAAA,2DAA2D;;;AAAG,MAAM,iBAAiB,CAAC,MAAM,QAAQ,IAAI,CAAC;AACzG,SAAS,IAAI,GAAG,EAAE,IAAI,EAAE,KAAK;IACzB,IAAI,KAAK,MAAM,GAAG,GAAG;QACjB,MAAM,UAAU;eACT;SACN;QACD,MAAM,MAAM,QAAQ,KAAK;QACzB,MAAM,UAAU,OAAO,CAAC,EAAE;QAC1B,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YACX,GAAG,CAAC,IAAI,GAAG,eAAe,WAAW,EAAE,GAAG,CAAC;QAC/C,OAAO,IAAI,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,eAAe,UAAU;YAC5D,GAAG,CAAC,IAAI,GAAG,OAAO,WAAW,CAAC,OAAO,OAAO,CAAC,GAAG,CAAC,IAAI;QACzD;QACA,IAAI,GAAG,CAAC,IAAI,EAAE,SAAS;QACvB;IACJ;IACA,MAAM,IAAI,IAAI,CAAC,EAAE;IACjB,IAAI,GAAG,CAAC,EAAE,KAAK,WAAW;QACtB,GAAG,CAAC,EAAE,GAAG;IACb,OAAO,IAAI,MAAM,OAAO,CAAC,GAAG,CAAC,EAAE,GAAG;QAC9B,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC;IAChB,OAAO;QACH,GAAG,CAAC,EAAE,GAAG;YACL,GAAG,CAAC,EAAE;YACN;SACH;IACL;AACJ;AACA,SAAS,iBAAiB,QAAQ;IAC9B,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,SAAS,OAAO,GAAG;QAC1C,MAAM,QAAQ,IAAI,KAAK,CAAC,YAAY,MAAM,CAAC;QAC3C,IAAI,KAAK,OAAO;IACpB;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1225, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/isAbortError.mjs"],"sourcesContent":["import { isObject } from '../utils.mjs';\n\nfunction isAbortError(error) {\n    return isObject(error) && error['name'] === 'AbortError';\n}\n\nexport { isAbortError };\n"],"names":[],"mappings":";;;AAAA;;AAEA,SAAS,aAAa,KAAK;IACvB,OAAO,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,UAAU,KAAK,CAAC,OAAO,KAAK;AAChD","ignoreList":[0]}},
    {"offset": {"line": 1234, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1240, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/vendor/unpromise/unpromise.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/unbound-method */ function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar _computedKey;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n * which is retained for the lifetime of the original Promise.\n */ const subscribableCache = new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n * SubscribedPromises (settled promises are not subscribed - they resolve\n * immediately). */ const NOOP = ()=>{\n// noop\n};\n_computedKey = Symbol.toStringTag;\nlet _computedKey1 = _computedKey;\n/**\n * Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n * created once, cached and reused throughout the lifetime of the Promise. Get a\n * Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n *\n * The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n * `.then()` and `.catch()` just once. Promises derived from it use a\n * subscription- (and unsubscription-) based mechanism that monitors these\n * handlers.\n *\n * Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n * `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n * `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n * from the original, potentially long-lived Promise, eliminating memory leaks.\n *\n * This approach can eliminate the memory leaks that otherwise come about from\n * repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n * times on the same long-lived native Promise (subscriptions which can never be\n * cleaned up).\n *\n * `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n * any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n * the scenes, `resolve` is implemented simply as\n * `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n * to tidy up!\n *\n */ class Unpromise {\n    /** Create a promise that mitigates uncontrolled subscription to a long-lived\n   * Promise via .then() and .catch() - otherwise a source of memory leaks.\n   *\n   * The returned promise has an `unsubscribe()` method which can be called when\n   * the Promise is no longer being tracked by application logic, and which\n   * ensures that there is no reference chain from the original promise to the\n   * new one, and therefore no memory leak.\n   *\n   * If original promise has not yet settled, this adds a new unique promise\n   * that listens to then/catch events, along with an `unsubscribe()` method to\n   * detach it.\n   *\n   * If original promise has settled, then creates a new Promise.resolve() or\n   * Promise.reject() and provided unsubscribe is a noop.\n   *\n   * If you call `unsubscribe()` before the returned Promise has settled, it\n   * will never settle.\n   */ subscribe() {\n        // in all cases we will combine some promise with its unsubscribe function\n        let promise;\n        let unsubscribe;\n        const { settlement } = this;\n        if (settlement === null) {\n            // not yet settled - subscribe new promise. Expect eventual settlement\n            if (this.subscribers === null) {\n                // invariant - it is not settled, so it must have subscribers\n                throw new Error(\"Unpromise settled but still has subscribers\");\n            }\n            const subscriber = withResolvers();\n            this.subscribers = listWithMember(this.subscribers, subscriber);\n            promise = subscriber.promise;\n            unsubscribe = ()=>{\n                if (this.subscribers !== null) {\n                    this.subscribers = listWithoutMember(this.subscribers, subscriber);\n                }\n            };\n        } else {\n            // settled - don't create subscribed promise. Just resolve or reject\n            const { status } = settlement;\n            if (status === \"fulfilled\") {\n                promise = Promise.resolve(settlement.value);\n            } else {\n                promise = Promise.reject(settlement.reason);\n            }\n            unsubscribe = NOOP;\n        }\n        // extend promise signature with the extra method\n        return Object.assign(promise, {\n            unsubscribe\n        });\n    }\n    /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */ then(onfulfilled, onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.then(onfulfilled, onrejected), {\n            unsubscribe\n        });\n    }\n    catch(onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.catch(onrejected), {\n            unsubscribe\n        });\n    }\n    finally(onfinally) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.finally(onfinally), {\n            unsubscribe\n        });\n    }\n    /** Unpromise STATIC METHODS */ /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n   * of the provided Promise reference) */ static proxy(promise) {\n        const cached = Unpromise.getSubscribablePromise(promise);\n        return typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n    }\n    /** Create and store an Unpromise keyed by an original Promise. */ static createSubscribablePromise(promise) {\n        const created = new Unpromise(promise);\n        subscribableCache.set(promise, created); // resolve promise to unpromise\n        subscribableCache.set(created, created); // resolve the unpromise to itself\n        return created;\n    }\n    /** Retrieve a previously-created Unpromise keyed by an original Promise. */ static getSubscribablePromise(promise) {\n        return subscribableCache.get(promise);\n    }\n    /** Promise STATIC METHODS */ /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n   * it (that can be later unsubscribed to eliminate Memory leaks) */ static resolve(value) {\n        const promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n        return Unpromise.proxy(promise).subscribe();\n    }\n    static async any(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.any(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    static async race(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.race(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    /** Create a race of SubscribedPromises that will fulfil to a single winning\n   * Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n   * accumulating .then() and .catch() subscribers. Allows simple logic to\n   * consume the result, like...\n   * ```ts\n   * const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n   * if(winner === promiseB){\n   *   const result = await promiseB;\n   *   // do the thing\n   * }\n   * ```\n   * */ static async raceReferences(promises) {\n        // map each promise to an eventual 1-tuple containing itself\n        const selfPromises = promises.map(resolveSelfTuple);\n        // now race them. They will fulfil to a readonly [P] or reject.\n        try {\n            return await Promise.race(selfPromises);\n        } finally{\n            for (const promise of selfPromises){\n                // unsubscribe proxy promises when the race is over to mitigate memory leaks\n                promise.unsubscribe();\n            }\n        }\n    }\n    constructor(arg){\n        /** INSTANCE IMPLEMENTATION */ /** The promise shadowed by this Unpromise<T>  */ _define_property(this, \"promise\", void 0);\n        /** Promises expecting eventual settlement (unless unsubscribed first). This list is deleted\n   * after the original promise settles - no further notifications will be issued. */ _define_property(this, \"subscribers\", []);\n        /** The Promise's settlement (recorded when it fulfils or rejects). This is consulted when\n   * calling .subscribe() .then() .catch() .finally() to see if an immediately-resolving Promise\n   * can be returned, and therefore subscription can be bypassed. */ _define_property(this, \"settlement\", null);\n        /** TOSTRING SUPPORT */ _define_property(this, _computedKey1, \"Unpromise\");\n        // handle either a Promise or a Promise executor function\n        if (typeof arg === \"function\") {\n            this.promise = new Promise(arg);\n        } else {\n            this.promise = arg;\n        }\n        // subscribe for eventual fulfilment and rejection\n        // handle PromiseLike objects (that at least have .then)\n        const thenReturn = this.promise.then((value)=>{\n            // atomically record fulfilment and detach subscriber list\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"fulfilled\",\n                value\n            };\n            // notify fulfilment to subscriber list\n            subscribers?.forEach(({ resolve })=>{\n                resolve(value);\n            });\n        });\n        // handle Promise (that also have a .catch behaviour)\n        if (\"catch\" in thenReturn) {\n            thenReturn.catch((reason)=>{\n                // atomically record rejection and detach subscriber list\n                const { subscribers } = this;\n                this.subscribers = null;\n                this.settlement = {\n                    status: \"rejected\",\n                    reason\n                };\n                // notify rejection to subscriber list\n                subscribers?.forEach(({ reject })=>{\n                    reject(reason);\n                });\n            });\n        }\n    }\n}\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n * awaiting the eventual Promise ***reference*** (easy to destructure and\n * exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n * may be ambiguous and therefore hard to identify as the winner of a race).\n * You can call unsubscribe on the Promise to mitigate memory leaks.\n * */ function resolveSelfTuple(promise) {\n    return Unpromise.proxy(promise).then(()=>[\n            promise\n        ]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */ /** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */ function withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject)=>{\n        resolve = _resolve;\n        reject = _reject;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n/** IMMUTABLE LIST OPERATIONS */ function listWithMember(arr, member) {\n    return [\n        ...arr,\n        member\n    ];\n}\nfunction listWithoutIndex(arr, index) {\n    return [\n        ...arr.slice(0, index),\n        ...arr.slice(index + 1)\n    ];\n}\nfunction listWithoutMember(arr, member) {\n    const index = arr.indexOf(member);\n    if (index !== -1) {\n        return listWithoutIndex(arr, index);\n    }\n    return arr;\n}\n\nexport { Unpromise, resolveSelfTuple };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1532, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1538, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/disposable.mjs"],"sourcesContent":["// @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\nvar _Symbol, // @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\n_Symbol1;\n(_Symbol = Symbol).dispose ?? (_Symbol.dispose = Symbol());\n(_Symbol1 = Symbol).asyncDispose ?? (_Symbol1.asyncDispose = Symbol());\n/**\n * Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n * The returned object is the original value augmented with a Symbol.dispose method.\n * @param thing The value to make disposable\n * @param dispose Function to call when disposing the resource\n * @returns The original value with Symbol.dispose method added\n */ function makeResource(thing, dispose) {\n    const it = thing;\n    // eslint-disable-next-line no-restricted-syntax\n    if (it[Symbol.dispose]) {\n        throw new Error('Symbol.dispose already exists');\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    it[Symbol.dispose] = dispose;\n    return it;\n}\n/**\n * Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n * The returned object is the original value augmented with a Symbol.asyncDispose method.\n * @param thing The value to make async disposable\n * @param dispose Async function to call when disposing the resource\n * @returns The original value with Symbol.asyncDispose method added\n */ function makeAsyncResource(thing, dispose) {\n    const it = thing;\n    // eslint-disable-next-line no-restricted-syntax\n    if (it[Symbol.asyncDispose]) {\n        throw new Error('Symbol.asyncDispose already exists');\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    it[Symbol.asyncDispose] = dispose;\n    return it;\n}\n\nexport { makeAsyncResource, makeResource };\n"],"names":[],"mappings":"AAAA,wCAAwC;AACxC,gDAAgD;;;;;AAChD,IAAI,SACJ,gDAAgD;AAChD;AACA,CAAC,UAAU,MAAM,EAAE,OAAO,IAAI,CAAC,QAAQ,OAAO,GAAG,QAAQ;AACzD,CAAC,WAAW,MAAM,EAAE,YAAY,IAAI,CAAC,SAAS,YAAY,GAAG,QAAQ;AACrE;;;;;;CAMC,GAAG,SAAS,aAAa,KAAK,EAAE,OAAO;IACpC,MAAM,KAAK;IACX,gDAAgD;IAChD,IAAI,EAAE,CAAC,OAAO,OAAO,CAAC,EAAE;QACpB,MAAM,IAAI,MAAM;IACpB;IACA,gDAAgD;IAChD,EAAE,CAAC,OAAO,OAAO,CAAC,GAAG;IACrB,OAAO;AACX;AACA;;;;;;CAMC,GAAG,SAAS,kBAAkB,KAAK,EAAE,OAAO;IACzC,MAAM,KAAK;IACX,gDAAgD;IAChD,IAAI,EAAE,CAAC,OAAO,YAAY,CAAC,EAAE;QACzB,MAAM,IAAI,MAAM;IACpB;IACA,gDAAgD;IAChD,EAAE,CAAC,OAAO,YAAY,CAAC,GAAG;IAC1B,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1581, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1587, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/timerResource.mjs"],"sourcesContent":["import { makeResource } from './disposable.mjs';\n\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n    let timer = null;\n    return makeResource({\n        start () {\n            if (timer) {\n                throw new Error('Timer already started');\n            }\n            const promise = new Promise((resolve)=>{\n                timer = setTimeout(()=>resolve(disposablePromiseTimerResult), ms);\n            });\n            return promise;\n        }\n    }, ()=>{\n        if (timer) {\n            clearTimeout(timer);\n        }\n    });\n}\n\nexport { disposablePromiseTimerResult, timerResource };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,+BAA+B;AACrC,SAAS,cAAc,EAAE;IACrB,IAAI,QAAQ;IACZ,OAAO,CAAA,GAAA,iNAAA,CAAA,eAAY,AAAD,EAAE;QAChB;YACI,IAAI,OAAO;gBACP,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,UAAU,IAAI,QAAQ,CAAC;gBACzB,QAAQ,WAAW,IAAI,QAAQ,+BAA+B;YAClE;YACA,OAAO;QACX;IACJ,GAAG;QACC,IAAI,OAAO;YACP,aAAa;QACjB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1619, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/asyncIterable.mjs"],"sourcesContent":["import { Unpromise } from '../../../vendor/unpromise/unpromise.mjs';\nimport { makeAsyncResource } from './disposable.mjs';\nimport { timerResource, disposablePromiseTimerResult } from './timerResource.mjs';\n\nfunction _ts_add_disposable_resource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nfunction _ts_dispose_resources(env) {\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n        var e = new Error(message);\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n    };\n    return (_ts_dispose_resources = function _ts_dispose_resources(env) {\n        function fail(e) {\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        var r, s = 0;\n        function next() {\n            while(r = env.stack.pop()){\n                try {\n                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                    if (r.dispose) {\n                        var result = r.dispose.call(r.value);\n                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                            fail(e);\n                            return next();\n                        });\n                    } else s |= 1;\n                } catch (e) {\n                    fail(e);\n                }\n            }\n            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    })(env);\n}\nfunction iteratorResource(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    return makeAsyncResource(iterator, async ()=>{\n        await iterator.return?.();\n    });\n}\n/**\n * Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically stops after the specified duration.\n */ async function* withMaxDuration(iterable, opts) {\n    const env = {\n        stack: [],\n        error: void 0,\n        hasError: false\n    };\n    try {\n        const iterator = _ts_add_disposable_resource(env, iteratorResource(iterable), true);\n        ;\n        const timer = _ts_add_disposable_resource(env, timerResource(opts.maxDurationMs), false);\n        ;\n        const timerPromise = timer.start();\n        // declaration outside the loop for garbage collection reasons\n        let result;\n        while(true){\n            result = await Unpromise.race([\n                iterator.next(),\n                timerPromise\n            ]);\n            if (result === disposablePromiseTimerResult) {\n                // cancelled due to timeout\n                const res = await iterator.return?.();\n                return res?.value;\n            }\n            if (result.done) {\n                return result;\n            }\n            yield result.value;\n            // free up reference for garbage collection\n            result = null;\n        }\n    } catch (e) {\n        env.error = e;\n        env.hasError = true;\n    } finally{\n        const result = _ts_dispose_resources(env);\n        if (result) await result;\n    }\n}\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n * {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n * values may still come through. After this period, the generator stops.\n */ async function* takeWithGrace(iterable, opts) {\n    const env = {\n        stack: [],\n        error: void 0,\n        hasError: false\n    };\n    try {\n        const iterator = _ts_add_disposable_resource(env, iteratorResource(iterable), true);\n        ;\n        // declaration outside the loop for garbage collection reasons\n        let result;\n        const timer = _ts_add_disposable_resource(env, timerResource(opts.gracePeriodMs), false);\n        ;\n        let count = opts.count;\n        let timerPromise = new Promise(()=>{\n        // never resolves\n        });\n        while(true){\n            result = await Unpromise.race([\n                iterator.next(),\n                timerPromise\n            ]);\n            if (result === disposablePromiseTimerResult) {\n                // cancelled\n                const res = await iterator.return?.();\n                return res?.value;\n            }\n            if (result.done) {\n                return result.value;\n            }\n            yield result.value;\n            if (--count === 0) {\n                timerPromise = timer.start();\n            }\n            // free up reference for garbage collection\n            result = null;\n        }\n    } catch (e) {\n        env.error = e;\n        env.hasError = true;\n    } finally{\n        const result = _ts_dispose_resources(env);\n        if (result) await result;\n    }\n}\n\nexport { iteratorResource, takeWithGrace, withMaxDuration };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1792, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1798, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/createDeferred.mjs"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */ function createDeferred() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n\nexport { createDeferred };\n"],"names":[],"mappings":"AAAA,2DAA2D;;;AAAG,SAAS;IACnE,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;QAC9B,UAAU;QACV,SAAS;IACb;IACA,OAAO;QACH;QACA,SAAS;QACT,QAAQ;IACZ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1815, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1821, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.mjs"],"sourcesContent":["import { createDeferred } from './createDeferred.mjs';\nimport { makeAsyncResource } from './disposable.mjs';\n\nfunction _ts_add_disposable_resource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nfunction _ts_dispose_resources(env) {\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n        var e = new Error(message);\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n    };\n    return (_ts_dispose_resources = function _ts_dispose_resources(env) {\n        function fail(e) {\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        var r, s = 0;\n        function next() {\n            while(r = env.stack.pop()){\n                try {\n                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                    if (r.dispose) {\n                        var result = r.dispose.call(r.value);\n                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                            fail(e);\n                            return next();\n                        });\n                    } else s |= 1;\n                } catch (e) {\n                    fail(e);\n                }\n            }\n            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    })(env);\n}\nfunction createManagedIterator(iterable, onResult) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let state = 'idle';\n    function cleanup() {\n        state = 'done';\n        onResult = ()=>{\n        // noop\n        };\n    }\n    function pull() {\n        if (state !== 'idle') {\n            return;\n        }\n        state = 'pending';\n        const next = iterator.next();\n        next.then((result)=>{\n            if (result.done) {\n                state = 'done';\n                onResult({\n                    status: 'return',\n                    value: result.value\n                });\n                cleanup();\n                return;\n            }\n            state = 'idle';\n            onResult({\n                status: 'yield',\n                value: result.value\n            });\n        }).catch((cause)=>{\n            onResult({\n                status: 'error',\n                error: cause\n            });\n            cleanup();\n        });\n    }\n    return {\n        pull,\n        destroy: async ()=>{\n            cleanup();\n            await iterator.return?.();\n        }\n    };\n}\n/**\n * Creates a new async iterable that merges multiple async iterables into a single stream.\n * Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n *\n * New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n *\n * If any of the input iterables throws an error, that error will be propagated through the merged stream.\n * Other iterables will not continue to be processed.\n *\n * @template TYield The type of values yielded by the input iterables\n */ function mergeAsyncIterables() {\n    let state = 'idle';\n    let flushSignal = createDeferred();\n    /**\n   * used while {@link state} is `idle`\n   */ const iterables = [];\n    /**\n   * used while {@link state} is `pending`\n   */ const iterators = new Set();\n    const buffer = [];\n    function initIterable(iterable) {\n        if (state !== 'pending') {\n            // shouldn't happen\n            return;\n        }\n        const iterator = createManagedIterator(iterable, (result)=>{\n            if (state !== 'pending') {\n                // shouldn't happen\n                return;\n            }\n            switch(result.status){\n                case 'yield':\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    break;\n                case 'return':\n                    iterators.delete(iterator);\n                    break;\n                case 'error':\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    iterators.delete(iterator);\n                    break;\n            }\n            flushSignal.resolve();\n        });\n        iterators.add(iterator);\n        iterator.pull();\n    }\n    return {\n        add (iterable) {\n            switch(state){\n                case 'idle':\n                    iterables.push(iterable);\n                    break;\n                case 'pending':\n                    initIterable(iterable);\n                    break;\n            }\n        },\n        async *[Symbol.asyncIterator] () {\n            const env = {\n                stack: [],\n                error: void 0,\n                hasError: false\n            };\n            try {\n                if (state !== 'idle') {\n                    throw new Error('Cannot iterate twice');\n                }\n                state = 'pending';\n                const _finally = _ts_add_disposable_resource(env, makeAsyncResource({}, async ()=>{\n                    state = 'done';\n                    const errors = [];\n                    await Promise.all(Array.from(iterators.values()).map(async (it)=>{\n                        try {\n                            await it.destroy();\n                        } catch (cause) {\n                            errors.push(cause);\n                        }\n                    }));\n                    buffer.length = 0;\n                    iterators.clear();\n                    flushSignal.resolve();\n                    if (errors.length > 0) {\n                        throw new AggregateError(errors);\n                    }\n                }), true);\n                ;\n                while(iterables.length > 0){\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    initIterable(iterables.shift());\n                }\n                while(iterators.size > 0){\n                    await flushSignal.promise;\n                    while(buffer.length > 0){\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const [iterator, result] = buffer.shift();\n                        switch(result.status){\n                            case 'yield':\n                                yield result.value;\n                                iterator.pull();\n                                break;\n                            case 'error':\n                                throw result.error;\n                        }\n                    }\n                    flushSignal = createDeferred();\n                }\n            } catch (e) {\n                env.error = e;\n                env.hasError = true;\n            } finally{\n                const result = _ts_dispose_resources(env);\n                if (result) await result;\n            }\n        }\n    };\n}\n\nexport { mergeAsyncIterables };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2063, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2069, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/readableStreamFrom.mjs"],"sourcesContent":["/**\n * Creates a ReadableStream from an AsyncIterable.\n *\n * @param iterable - The source AsyncIterable to stream from\n * @returns A ReadableStream that yields values from the AsyncIterable\n */ function readableStreamFrom(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async cancel () {\n            await iterator.return?.();\n        },\n        async pull (controller) {\n            const result = await iterator.next();\n            if (result.done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(result.value);\n        }\n    });\n}\n\nexport { readableStreamFrom };\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;AAAG,SAAS,mBAAmB,QAAQ;IACpC,MAAM,WAAW,QAAQ,CAAC,OAAO,aAAa,CAAC;IAC/C,OAAO,IAAI,eAAe;QACtB,MAAM;YACF,MAAM,SAAS,MAAM;QACzB;QACA,MAAM,MAAM,UAAU;YAClB,MAAM,SAAS,MAAM,SAAS,IAAI;YAClC,IAAI,OAAO,IAAI,EAAE;gBACb,WAAW,KAAK;gBAChB;YACJ;YACA,WAAW,OAAO,CAAC,OAAO,KAAK;QACnC;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2094, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2100, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/jsonl.mjs"],"sourcesContent":["import { isObject, isFunction, run, isAsyncIterable } from '../utils.mjs';\nimport { iteratorResource } from './utils/asyncIterable.mjs';\nimport { createDeferred } from './utils/createDeferred.mjs';\nimport { makeResource } from './utils/disposable.mjs';\nimport { mergeAsyncIterables } from './utils/mergeAsyncIterables.mjs';\nimport { readableStreamFrom } from './utils/readableStreamFrom.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _ts_add_disposable_resource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nfunction _ts_dispose_resources(env) {\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n        var e = new Error(message);\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n    };\n    return (_ts_dispose_resources = function _ts_dispose_resources(env) {\n        function fail(e) {\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        var r, s = 0;\n        function next() {\n            while(r = env.stack.pop()){\n                try {\n                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                    if (r.dispose) {\n                        var result = r.dispose.call(r.value);\n                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                            fail(e);\n                            return next();\n                        });\n                    } else s |= 1;\n                } catch (e) {\n                    fail(e);\n                }\n            }\n            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    })(env);\n}\n// ---------- types\n// ---------- types\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n    return (isObject(value) || isFunction(value)) && typeof value?.['then'] === 'function' && typeof value?.['catch'] === 'function';\n}\nclass MaxDepthError extends Error {\n    constructor(path){\n        super('Max depth reached at path: ' + path.join('.')), _define_property(this, \"path\", void 0), this.path = path;\n    }\n}\nasync function* createBatchStreamProducer(opts) {\n    const { data } = opts;\n    let counter = 0;\n    const placeholder = 0;\n    const mergedIterables = mergeAsyncIterables();\n    function registerAsync(callback) {\n        const idx = counter++;\n        const iterable = callback(idx);\n        mergedIterables.add(iterable);\n        return idx;\n    }\n    function encodePromise(promise, path) {\n        return registerAsync(async function*(idx) {\n            const error = checkMaxDepth(path);\n            if (error) {\n                // Catch any errors from the original promise to ensure they're reported\n                promise.catch((cause)=>{\n                    opts.onError?.({\n                        error: cause,\n                        path\n                    });\n                });\n                // Replace the promise with a rejected one containing the max depth error\n                promise = Promise.reject(error);\n            }\n            try {\n                const next = await promise;\n                yield [\n                    idx,\n                    PROMISE_STATUS_FULFILLED,\n                    encode(next, path)\n                ];\n            } catch (cause) {\n                opts.onError?.({\n                    error: cause,\n                    path\n                });\n                yield [\n                    idx,\n                    PROMISE_STATUS_REJECTED,\n                    opts.formatError?.({\n                        error: cause,\n                        path\n                    })\n                ];\n            }\n        });\n    }\n    function encodeAsyncIterable(iterable, path) {\n        return registerAsync(async function*(idx) {\n            const env = {\n                stack: [],\n                error: void 0,\n                hasError: false\n            };\n            try {\n                const error = checkMaxDepth(path);\n                if (error) {\n                    throw error;\n                }\n                const iterator = _ts_add_disposable_resource(env, iteratorResource(iterable), true);\n                ;\n                try {\n                    while(true){\n                        const next = await iterator.next();\n                        if (next.done) {\n                            yield [\n                                idx,\n                                ASYNC_ITERABLE_STATUS_RETURN,\n                                encode(next.value, path)\n                            ];\n                            break;\n                        }\n                        yield [\n                            idx,\n                            ASYNC_ITERABLE_STATUS_YIELD,\n                            encode(next.value, path)\n                        ];\n                    }\n                } catch (cause) {\n                    opts.onError?.({\n                        error: cause,\n                        path\n                    });\n                    yield [\n                        idx,\n                        ASYNC_ITERABLE_STATUS_ERROR,\n                        opts.formatError?.({\n                            error: cause,\n                            path\n                        })\n                    ];\n                }\n            } catch (e) {\n                env.error = e;\n                env.hasError = true;\n            } finally{\n                const result = _ts_dispose_resources(env);\n                if (result) await result;\n            }\n        });\n    }\n    function checkMaxDepth(path) {\n        if (opts.maxDepth && path.length > opts.maxDepth) {\n            return new MaxDepthError(path);\n        }\n        return null;\n    }\n    function encodeAsync(value, path) {\n        if (isPromise(value)) {\n            return [\n                CHUNK_VALUE_TYPE_PROMISE,\n                encodePromise(value, path)\n            ];\n        }\n        if (isAsyncIterable(value)) {\n            if (opts.maxDepth && path.length >= opts.maxDepth) {\n                throw new Error('Max depth reached');\n            }\n            return [\n                CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n                encodeAsyncIterable(value, path)\n            ];\n        }\n        return null;\n    }\n    function encode(value, path) {\n        if (value === undefined) {\n            return [\n                []\n            ];\n        }\n        if (!isObject(value)) {\n            return [\n                [\n                    value\n                ]\n            ];\n        }\n        const reg = encodeAsync(value, path);\n        if (reg) {\n            return [\n                [\n                    placeholder\n                ],\n                [\n                    null,\n                    ...reg\n                ]\n            ];\n        }\n        const newObj = {};\n        const asyncValues = [];\n        for (const [key, item] of Object.entries(value)){\n            const transformed = encodeAsync(item, [\n                ...path,\n                key\n            ]);\n            if (!transformed) {\n                newObj[key] = item;\n                continue;\n            }\n            newObj[key] = placeholder;\n            asyncValues.push([\n                key,\n                ...transformed\n            ]);\n        }\n        return [\n            [\n                newObj\n            ],\n            ...asyncValues\n        ];\n    }\n    const newHead = {};\n    for (const [key, item] of Object.entries(data)){\n        newHead[key] = encode(item, [\n            key\n        ]);\n    }\n    yield newHead;\n    for await (const value of mergedIterables){\n        yield value;\n    }\n}\n/**\n * JSON Lines stream producer\n * @see https://jsonlines.org/\n */ function jsonlStreamProducer(opts) {\n    let stream = readableStreamFrom(createBatchStreamProducer(opts));\n    const { serialize } = opts;\n    if (serialize) {\n        stream = stream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(serialize(chunk));\n            }\n        }));\n    }\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(JSON.stringify(chunk) + '\\n');\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nclass StreamInterruptedError extends Error {\n    constructor(cause){\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super('Invalid response or stream interrupted', {\n            cause\n        });\n    }\n}\nclass AsyncError extends Error {\n    constructor(data){\n        super('Received error from server'), _define_property(this, \"data\", void 0), this.data = data;\n    }\n}\nconst nodeJsStreamToReaderEsque = (source)=>{\n    return {\n        getReader () {\n            const stream = new ReadableStream({\n                start (controller) {\n                    source.on('data', (chunk)=>{\n                        controller.enqueue(chunk);\n                    });\n                    source.on('end', ()=>{\n                        controller.close();\n                    });\n                    source.on('error', (error)=>{\n                        controller.error(error);\n                    });\n                }\n            });\n            return stream.getReader();\n        }\n    };\n};\nfunction createLineAccumulator(from) {\n    const reader = 'getReader' in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n    let lineAggregate = '';\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await reader.read();\n            if (done) {\n                controller.close();\n            } else {\n                controller.enqueue(value);\n            }\n        },\n        cancel () {\n            return reader.cancel();\n        }\n    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            lineAggregate += chunk;\n            const parts = lineAggregate.split('\\n');\n            lineAggregate = parts.pop() ?? '';\n            for (const part of parts){\n                controller.enqueue(part);\n            }\n        }\n    }));\n}\nfunction createConsumerStream(from) {\n    const stream = createLineAccumulator(from);\n    let sentHead = false;\n    return stream.pipeThrough(new TransformStream({\n        transform (line, controller) {\n            if (!sentHead) {\n                const head = JSON.parse(line);\n                controller.enqueue(head);\n                sentHead = true;\n            } else {\n                const chunk = JSON.parse(line);\n                controller.enqueue(chunk);\n            }\n        }\n    }));\n}\n/**\n * Creates a handler for managing stream controllers and their lifecycle\n */ function createStreamsManager(abortController) {\n    const controllerMap = new Map();\n    /**\n   * Checks if there are no pending controllers or deferred promises\n   */ function isEmpty() {\n        return Array.from(controllerMap.values()).every((c)=>c.closed);\n    }\n    /**\n   * Creates a stream controller\n   */ function createStreamController() {\n        let originalController;\n        const stream = new ReadableStream({\n            start (controller) {\n                originalController = controller;\n            }\n        });\n        const streamController = {\n            enqueue: (v)=>originalController.enqueue(v),\n            close: ()=>{\n                originalController.close();\n                // mark as closed and remove methods\n                Object.assign(streamController, {\n                    closed: true,\n                    close: ()=>{\n                    // noop\n                    },\n                    enqueue: ()=>{\n                    // noop\n                    },\n                    getReaderResource: null\n                });\n                if (isEmpty()) {\n                    abortController.abort();\n                }\n            },\n            closed: false,\n            getReaderResource: ()=>{\n                const reader = stream.getReader();\n                return makeResource(reader, ()=>{\n                    reader.releaseLock();\n                    streamController.close();\n                });\n            }\n        };\n        return streamController;\n    }\n    /**\n   * Gets or creates a stream controller\n   */ function getOrCreate(chunkId) {\n        let c = controllerMap.get(chunkId);\n        if (!c) {\n            c = createStreamController();\n            controllerMap.set(chunkId, c);\n        }\n        return c;\n    }\n    /**\n   * Cancels all pending controllers and rejects deferred promises\n   */ function cancelAll(reason) {\n        const error = new StreamInterruptedError(reason);\n        for (const controller of controllerMap.values()){\n            controller.enqueue(error);\n            controller.close();\n        }\n    }\n    return {\n        getOrCreate,\n        isEmpty,\n        cancelAll\n    };\n}\n/**\n * JSON Lines stream consumer\n * @see https://jsonlines.org/\n */ async function jsonlStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let source = createConsumerStream(opts.from);\n    if (deserialize) {\n        source = source.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(deserialize(chunk));\n            }\n        }));\n    }\n    let headDeferred = createDeferred();\n    const streamManager = createStreamsManager(opts.abortController);\n    function decodeChunkDefinition(value) {\n        const [_path, type, chunkId] = value;\n        const controller = streamManager.getOrCreate(chunkId);\n        switch(type){\n            case CHUNK_VALUE_TYPE_PROMISE:\n                {\n                    return run(async ()=>{\n                        const env = {\n                            stack: [],\n                            error: void 0,\n                            hasError: false\n                        };\n                        try {\n                            const reader = _ts_add_disposable_resource(env, controller.getReaderResource(), false);\n                            ;\n                            const { value } = await reader.read();\n                            if (value instanceof StreamInterruptedError) {\n                                throw value;\n                            }\n                            const [_chunkId, status, data] = value;\n                            switch(status){\n                                case PROMISE_STATUS_FULFILLED:\n                                    return decode(data);\n                                case PROMISE_STATUS_REJECTED:\n                                    throw opts.formatError?.({\n                                        error: data\n                                    }) ?? new AsyncError(data);\n                            }\n                        } catch (e) {\n                            env.error = e;\n                            env.hasError = true;\n                        } finally{\n                            _ts_dispose_resources(env);\n                        }\n                    });\n                }\n            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:\n                {\n                    return run(async function*() {\n                        const env = {\n                            stack: [],\n                            error: void 0,\n                            hasError: false\n                        };\n                        try {\n                            const reader = _ts_add_disposable_resource(env, controller.getReaderResource(), false);\n                            ;\n                            while(true){\n                                const { value } = await reader.read();\n                                if (value instanceof StreamInterruptedError) {\n                                    throw value;\n                                }\n                                const [_chunkId, status, data] = value;\n                                switch(status){\n                                    case ASYNC_ITERABLE_STATUS_YIELD:\n                                        yield decode(data);\n                                        break;\n                                    case ASYNC_ITERABLE_STATUS_RETURN:\n                                        return decode(data);\n                                    case ASYNC_ITERABLE_STATUS_ERROR:\n                                        throw opts.formatError?.({\n                                            error: data\n                                        }) ?? new AsyncError(data);\n                                }\n                            }\n                        } catch (e) {\n                            env.error = e;\n                            env.hasError = true;\n                        } finally{\n                            _ts_dispose_resources(env);\n                        }\n                    });\n                }\n        }\n    }\n    function decode(value) {\n        const [[data], ...asyncProps] = value;\n        for (const value of asyncProps){\n            const [key] = value;\n            const decoded = decodeChunkDefinition(value);\n            if (key === null) {\n                return decoded;\n            }\n            data[key] = decoded;\n        }\n        return data;\n    }\n    const closeOrAbort = (reason)=>{\n        const error = new StreamInterruptedError(reason);\n        headDeferred?.reject(error);\n        streamManager.cancelAll(error);\n    };\n    source.pipeTo(new WritableStream({\n        write (chunkOrHead) {\n            if (headDeferred) {\n                const head = chunkOrHead;\n                for (const [key, value] of Object.entries(chunkOrHead)){\n                    const parsed = decode(value);\n                    head[key] = parsed;\n                }\n                headDeferred.resolve(head);\n                headDeferred = null;\n                return;\n            }\n            const chunk = chunkOrHead;\n            const [idx] = chunk;\n            const controller = streamManager.getOrCreate(idx);\n            controller.enqueue(chunk);\n        },\n        close: closeOrAbort,\n        abort: closeOrAbort\n    }), {\n        signal: opts.abortController.signal\n    }).catch((error)=>{\n        opts.onError?.({\n            error\n        });\n        closeOrAbort(error);\n    });\n    return [\n        await headDeferred.promise,\n        streamManager\n    ];\n}\n\nexport { isPromise, jsonlStreamConsumer, jsonlStreamProducer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2706, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2712, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/tracked.mjs"],"sourcesContent":["const trackedSymbol = Symbol();\n/**\n * Produce a typed server-sent event message\n * @deprecated use `tracked(id, data)` instead\n */ function sse(event) {\n    return tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n    return Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n * Automatically track an event so that it can be resumed from a given id if the connection is lost\n */ function tracked(id, data) {\n    if (id === '') {\n        // This limitation could be removed by using different SSE event names / channels for tracked event and non-tracked event\n        throw new Error('`id` must not be an empty string as empty string is the same as not setting the id at all');\n    }\n    return [\n        id,\n        data,\n        trackedSymbol\n    ];\n}\n\nexport { isTrackedEnvelope, sse, tracked };\n"],"names":[],"mappings":";;;;;AAAA,MAAM,gBAAgB;AACtB;;;CAGC,GAAG,SAAS,IAAI,KAAK;IAClB,OAAO,QAAQ,MAAM,EAAE,EAAE,MAAM,IAAI;AACvC;AACA,SAAS,kBAAkB,KAAK;IAC5B,OAAO,MAAM,OAAO,CAAC,UAAU,KAAK,CAAC,EAAE,KAAK;AAChD;AACA;;CAEC,GAAG,SAAS,QAAQ,EAAE,EAAE,IAAI;IACzB,IAAI,OAAO,IAAI;QACX,yHAAyH;QACzH,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;QACH;QACA;QACA;KACH;AACL","ignoreList":[0]}},
    {"offset": {"line": 2741, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2747, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/utils/withPing.mjs"],"sourcesContent":["import { Unpromise } from '../../../vendor/unpromise/unpromise.mjs';\nimport { iteratorResource } from './asyncIterable.mjs';\nimport { timerResource, disposablePromiseTimerResult } from './timerResource.mjs';\n\nfunction _ts_add_disposable_resource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nfunction _ts_dispose_resources(env) {\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n        var e = new Error(message);\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n    };\n    return (_ts_dispose_resources = function _ts_dispose_resources(env) {\n        function fail(e) {\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        var r, s = 0;\n        function next() {\n            while(r = env.stack.pop()){\n                try {\n                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                    if (r.dispose) {\n                        var result = r.dispose.call(r.value);\n                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                            fail(e);\n                            return next();\n                        });\n                    } else s |= 1;\n                } catch (e) {\n                    fail(e);\n                }\n            }\n            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    })(env);\n}\nconst PING_SYM = Symbol('ping');\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n * whenever no value has been yielded for {@link pingIntervalMs}.\n */ async function* withPing(iterable, pingIntervalMs) {\n    const env = {\n        stack: [],\n        error: void 0,\n        hasError: false\n    };\n    try {\n        const iterator = _ts_add_disposable_resource(env, iteratorResource(iterable), true);\n        ;\n        // declaration outside the loop for garbage collection reasons\n        let result;\n        let nextPromise = iterator.next();\n        while(true){\n            const env = {\n                stack: [],\n                error: void 0,\n                hasError: false\n            };\n            try {\n                const pingPromise = _ts_add_disposable_resource(env, timerResource(pingIntervalMs), false);\n                ;\n                result = await Unpromise.race([\n                    nextPromise,\n                    pingPromise.start()\n                ]);\n                if (result === disposablePromiseTimerResult) {\n                    // cancelled\n                    yield PING_SYM;\n                    continue;\n                }\n                if (result.done) {\n                    return result.value;\n                }\n                nextPromise = iterator.next();\n                yield result.value;\n                // free up reference for garbage collection\n                result = null;\n            } catch (e) {\n                env.error = e;\n                env.hasError = true;\n            } finally{\n                _ts_dispose_resources(env);\n            }\n        }\n    } catch (e) {\n        env.error = e;\n        env.hasError = true;\n    } finally{\n        const result = _ts_dispose_resources(env);\n        if (result) await result;\n    }\n}\n\nexport { PING_SYM, withPing };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2879, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2885, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/stream/sse.mjs"],"sourcesContent":["import { Unpromise } from '../../vendor/unpromise/unpromise.mjs';\nimport { getTRPCErrorFromUnknown } from '../error/TRPCError.mjs';\nimport { isAbortError } from '../http/isAbortError.mjs';\nimport { run, identity } from '../utils.mjs';\nimport { isTrackedEnvelope } from './tracked.mjs';\nimport { takeWithGrace, withMaxDuration } from './utils/asyncIterable.mjs';\nimport { makeAsyncResource } from './utils/disposable.mjs';\nimport { readableStreamFrom } from './utils/readableStreamFrom.mjs';\nimport { timerResource, disposablePromiseTimerResult } from './utils/timerResource.mjs';\nimport { withPing, PING_SYM } from './utils/withPing.mjs';\n\nfunction _ts_add_disposable_resource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nfunction _ts_dispose_resources(env) {\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n        var e = new Error(message);\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n    };\n    return (_ts_dispose_resources = function _ts_dispose_resources(env) {\n        function fail(e) {\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        var r, s = 0;\n        function next() {\n            while(r = env.stack.pop()){\n                try {\n                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                    if (r.dispose) {\n                        var result = r.dispose.call(r.value);\n                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                            fail(e);\n                            return next();\n                        });\n                    } else s |= 1;\n                } catch (e) {\n                    fail(e);\n                }\n            }\n            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    })(env);\n}\nconst PING_EVENT = 'ping';\nconst SERIALIZED_ERROR_EVENT = 'serialized-error';\nconst CONNECTED_EVENT = 'connected';\n/**\n *\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */ function sseStreamProducer(opts) {\n    const { serialize = identity } = opts;\n    const ping = {\n        enabled: opts.ping?.enabled ?? false,\n        intervalMs: opts.ping?.intervalMs ?? 1000\n    };\n    const client = opts.client ?? {};\n    if (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) {\n        throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n    }\n    async function* generator() {\n        yield {\n            event: CONNECTED_EVENT,\n            data: JSON.stringify(client)\n        };\n        let iterable = opts.data;\n        if (opts.emitAndEndImmediately) {\n            iterable = takeWithGrace(iterable, {\n                count: 1,\n                gracePeriodMs: 1\n            });\n        }\n        if (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) {\n            iterable = withMaxDuration(iterable, {\n                maxDurationMs: opts.maxDurationMs\n            });\n        }\n        if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) {\n            iterable = withPing(iterable, ping.intervalMs);\n        }\n        // We need those declarations outside the loop for garbage collection reasons. If they were\n        // declared inside, they would not be freed until the next value is present.\n        let value;\n        let chunk;\n        for await (value of iterable){\n            if (value === PING_SYM) {\n                yield {\n                    event: PING_EVENT,\n                    data: ''\n                };\n                continue;\n            }\n            chunk = isTrackedEnvelope(value) ? {\n                id: value[0],\n                data: value[1]\n            } : {\n                data: value\n            };\n            chunk.data = JSON.stringify(serialize(chunk.data));\n            yield chunk;\n            // free up references for garbage collection\n            value = null;\n            chunk = null;\n        }\n    }\n    async function* generatorWithErrorHandling() {\n        try {\n            yield* generator();\n        } catch (cause) {\n            if (isAbortError(cause)) {\n                // ignore abort errors, send any other errors\n                return;\n            }\n            // `err` must be caused by `opts.data`, `JSON.stringify` or `serialize`.\n            // So, a user error in any case.\n            const error = getTRPCErrorFromUnknown(cause);\n            const data = opts.formatError?.({\n                error\n            }) ?? null;\n            yield {\n                event: SERIALIZED_ERROR_EVENT,\n                data: JSON.stringify(serialize(data))\n            };\n        }\n    }\n    const stream = readableStreamFrom(generatorWithErrorHandling());\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if ('event' in chunk) {\n                controller.enqueue(`event: ${chunk.event}\\n`);\n            }\n            if ('data' in chunk) {\n                controller.enqueue(`data: ${chunk.data}\\n`);\n            }\n            if ('id' in chunk) {\n                controller.enqueue(`id: ${chunk.id}\\n`);\n            }\n            if ('comment' in chunk) {\n                controller.enqueue(`: ${chunk.comment}\\n`);\n            }\n            controller.enqueue('\\n\\n');\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n    const env = {\n        stack: [],\n        error: void 0,\n        hasError: false\n    };\n    try {\n        const timeoutPromise = _ts_add_disposable_resource(env, timerResource(opts.timeoutMs), false);\n        ;\n        const res = await Unpromise.race([\n            opts.promise,\n            timeoutPromise.start()\n        ]);\n        if (res === disposablePromiseTimerResult) {\n            return await opts.onTimeout();\n        }\n        return res;\n    } catch (e) {\n        env.error = e;\n        env.hasError = true;\n    } finally{\n        _ts_dispose_resources(env);\n    }\n}\n/**\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */ function sseStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let clientOptions = {};\n    const signal = opts.signal;\n    let _es = null;\n    const createStream = ()=>new ReadableStream({\n            async start (controller) {\n                const [url, init] = await Promise.all([\n                    opts.url(),\n                    opts.init()\n                ]);\n                const eventSource = _es = new opts.EventSource(url, init);\n                controller.enqueue({\n                    type: 'connecting',\n                    eventSource: _es,\n                    event: null\n                });\n                eventSource.addEventListener(CONNECTED_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    const options = JSON.parse(msg.data);\n                    clientOptions = options;\n                    controller.enqueue({\n                        type: 'connected',\n                        options,\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    controller.enqueue({\n                        type: 'serialized-error',\n                        error: deserialize(JSON.parse(msg.data)),\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(PING_EVENT, ()=>{\n                    controller.enqueue({\n                        type: 'ping',\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener('error', (event)=>{\n                    if (eventSource.readyState === EventSource.CLOSED) {\n                        controller.error(event);\n                    } else {\n                        controller.enqueue({\n                            type: 'connecting',\n                            eventSource,\n                            event\n                        });\n                    }\n                });\n                eventSource.addEventListener('message', (_msg)=>{\n                    const msg = _msg;\n                    const chunk = deserialize(JSON.parse(msg.data));\n                    const def = {\n                        data: chunk\n                    };\n                    if (msg.lastEventId) {\n                        def.id = msg.lastEventId;\n                    }\n                    controller.enqueue({\n                        type: 'data',\n                        data: def,\n                        eventSource\n                    });\n                });\n                const onAbort = ()=>{\n                    try {\n                        eventSource.close();\n                        controller.close();\n                    } catch  {\n                    // ignore errors in case the controller is already closed\n                    }\n                };\n                if (signal.aborted) {\n                    onAbort();\n                } else {\n                    signal.addEventListener('abort', onAbort);\n                }\n            },\n            cancel () {\n                _es?.close();\n            }\n        });\n    const getStreamResource = ()=>{\n        let stream = createStream();\n        let reader = stream.getReader();\n        async function dispose() {\n            await reader.cancel();\n            _es = null;\n        }\n        return makeAsyncResource({\n            read () {\n                return reader.read();\n            },\n            async recreate () {\n                await dispose();\n                stream = createStream();\n                reader = stream.getReader();\n            }\n        }, dispose);\n    };\n    return run(async function*() {\n        const env = {\n            stack: [],\n            error: void 0,\n            hasError: false\n        };\n        try {\n            const stream = _ts_add_disposable_resource(env, getStreamResource(), true);\n            ;\n            while(true){\n                let promise = stream.read();\n                const timeoutMs = clientOptions.reconnectAfterInactivityMs;\n                if (timeoutMs) {\n                    promise = withTimeout({\n                        promise,\n                        timeoutMs,\n                        onTimeout: async ()=>{\n                            const res = {\n                                value: {\n                                    type: 'timeout',\n                                    ms: timeoutMs,\n                                    eventSource: _es\n                                },\n                                done: false\n                            };\n                            // Close and release old reader\n                            await stream.recreate();\n                            return res;\n                        }\n                    });\n                }\n                const result = await promise;\n                if (result.done) {\n                    return result.value;\n                }\n                yield result.value;\n            }\n        } catch (e) {\n            env.error = e;\n            env.hasError = true;\n        } finally{\n            const result = _ts_dispose_resources(env);\n            if (result) await result;\n        }\n    });\n}\nconst sseHeaders = {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-cache, no-transform',\n    'X-Accel-Buffering': 'no',\n    Connection: 'keep-alive'\n};\n\nexport { sseHeaders, sseStreamConsumer, sseStreamProducer };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3257, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3263, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/transformer.mjs"],"sourcesContent":["import { isObject } from './utils.mjs';\n\n/**\n * @internal\n */ function getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n * @internal\n */ const defaultTransformer = {\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\nfunction transformTRPCResponseItem(config, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, transformer) {\n    if ('error' in response) {\n        const error = transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, transformer) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, transformer);\n    } catch  {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error['code'] !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { defaultTransformer, getDataTransformer, transformResult, transformTRPCResponse };\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;CAEC,GAAG,SAAS,mBAAmB,WAAW;IACvC,IAAI,WAAW,aAAa;QACxB,OAAO;IACX;IACA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ;AACA;;CAEC,GAAG,MAAM,qBAAqB;IAC3B,OAAO;QACH,WAAW,CAAC,MAAM;QAClB,aAAa,CAAC,MAAM;IACxB;IACA,QAAQ;QACJ,WAAW,CAAC,MAAM;QAClB,aAAa,CAAC,MAAM;IACxB;AACJ;AACA,SAAS,0BAA0B,MAAM,EAAE,IAAI;IAC3C,IAAI,WAAW,MAAM;QACjB,OAAO;YACH,GAAG,IAAI;YACP,OAAO,OAAO,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,KAAK;QACzD;IACJ;IACA,IAAI,UAAU,KAAK,MAAM,EAAE;QACvB,OAAO;YACH,GAAG,IAAI;YACP,QAAQ;gBACJ,GAAG,KAAK,MAAM;gBACd,MAAM,OAAO,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,MAAM,CAAC,IAAI;YAC9D;QACJ;IACJ;IACA,OAAO;AACX;AACA;;EAEE,GAAG,SAAS,sBAAsB,MAAM,EAAE,WAAW;IACnD,OAAO,MAAM,OAAO,CAAC,eAAe,YAAY,GAAG,CAAC,CAAC,OAAO,0BAA0B,QAAQ,SAAS,0BAA0B,QAAQ;AAC7I;AACA,SAAS;AACT,+CAA+C;AAC/C,mEAAmE;AACnE,cAAc,GAAG,SAAS,qBAAqB,QAAQ,EAAE,WAAW;IAChE,IAAI,WAAW,UAAU;QACrB,MAAM,QAAQ,YAAY,WAAW,CAAC,SAAS,KAAK;QACpD,OAAO;YACH,IAAI;YACJ,OAAO;gBACH,GAAG,QAAQ;gBACX;YACJ;QACJ;IACJ;IACA,MAAM,SAAS;QACX,GAAG,SAAS,MAAM;QAClB,GAAG,CAAC,CAAC,SAAS,MAAM,CAAC,IAAI,IAAI,SAAS,MAAM,CAAC,IAAI,KAAK,MAAM,KAAK;YAC7D,MAAM;YACN,MAAM,YAAY,WAAW,CAAC,SAAS,MAAM,CAAC,IAAI;QACtD,CAAC;IACL;IACA,OAAO;QACH,IAAI;QACJ;IACJ;AACJ;AACA,MAAM,6BAA6B;IAC/B,aAAa;QACT,KAAK,CAAC;IACV;AACJ;AACA;;;CAGC,GAAG,SAAS,gBAAgB,QAAQ,EAAE,WAAW;IAC9C,IAAI;IACJ,IAAI;QACA,iDAAiD;QACjD,SAAS,qBAAqB,UAAU;IAC5C,EAAE,OAAO;QACL,MAAM,IAAI;IACd;IACA,gEAAgE;IAChE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,KAAK,CAAC,KAAK,KAAK,OAAO,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,KAAK,QAAQ,GAAG;QACjG,MAAM,IAAI;IACd;IACA,IAAI,OAAO,EAAE,IAAI,CAAC,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,MAAM,GAAG;QACvC,MAAM,IAAI;IACd;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 3369, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3375, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/http/resolveResponse.mjs"],"sourcesContent":["import { isObservable, observableToAsyncIterable } from '../../observable/observable.mjs';\nimport { getErrorShape } from '../error/getErrorShape.mjs';\nimport { getTRPCErrorFromUnknown, TRPCError } from '../error/TRPCError.mjs';\nimport { jsonlStreamProducer, isPromise } from '../stream/jsonl.mjs';\nimport { sseStreamProducer, sseHeaders } from '../stream/sse.mjs';\nimport { transformTRPCResponse } from '../transformer.mjs';\nimport { run, isAsyncIterable, isObject } from '../utils.mjs';\nimport { getRequestInfo } from './contentType.mjs';\nimport { getHTTPStatusCode } from './getHTTPStatusCode.mjs';\n\nfunction errorToAsyncIterable(err) {\n    return run(async function*() {\n        throw err;\n    });\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n    mutation: [\n        'POST'\n    ],\n    query: [\n        'GET'\n    ],\n    subscription: [\n        'GET'\n    ]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n    // never allow GET to do a mutation\n    mutation: [\n        'POST'\n    ],\n    query: [\n        'GET',\n        'POST'\n    ],\n    subscription: [\n        'GET',\n        'POST'\n    ]\n};\nfunction initResponse(initOpts) {\n    const { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n    let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;\n    const eagerGeneration = !untransformedJSON;\n    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [\n        untransformedJSON\n    ];\n    const meta = responseMeta?.({\n        ctx,\n        info,\n        paths: info?.calls.map((call)=>call.path),\n        data,\n        errors,\n        eagerGeneration,\n        type: info?.calls.find((call)=>call.procedure?._def.type)?.procedure?._def.type ?? 'unknown'\n    }) ?? {};\n    if (meta.headers) {\n        if (meta.headers instanceof Headers) {\n            for (const [key, value] of meta.headers.entries()){\n                headers.append(key, value);\n            }\n        } else {\n            /**\n       * @deprecated, delete in v12\n       */ for (const [key, value] of Object.entries(meta.headers)){\n                if (Array.isArray(value)) {\n                    for (const v of value){\n                        headers.append(key, v);\n                    }\n                } else if (typeof value === 'string') {\n                    headers.set(key, value);\n                }\n            }\n        }\n    }\n    if (meta.status) {\n        status = meta.status;\n    }\n    return {\n        status\n    };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n    const { router, req, onError } = errorOpts.opts;\n    const error = getTRPCErrorFromUnknown(cause);\n    onError?.({\n        error,\n        path: errorOpts.path,\n        input: errorOpts.input,\n        ctx: errorOpts.ctx,\n        type: errorOpts.type,\n        req\n    });\n    const untransformedJSON = {\n        error: getErrorShape({\n            config: router._def._config,\n            error,\n            type: errorOpts.type,\n            path: errorOpts.path,\n            input: errorOpts.input,\n            ctx: errorOpts.ctx\n        })\n    };\n    const transformedJSON = transformTRPCResponse(router._def._config, untransformedJSON);\n    const body = JSON.stringify(transformedJSON);\n    return {\n        error,\n        untransformedJSON,\n        body\n    };\n}\n/**\n * Check if a value is a stream-like object\n * - if it's an async iterable\n * - if it's an object with async iterables or promises\n */ function isDataStream(v) {\n    if (!isObject(v)) {\n        return false;\n    }\n    if (isAsyncIterable(v)) {\n        return true;\n    }\n    return Object.values(v).some(isPromise) || Object.values(v).some(isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n    const { router, req } = opts;\n    const headers = new Headers([\n        [\n            'vary',\n            'trpc-accept'\n        ]\n    ]);\n    const config = router._def._config;\n    const url = new URL(req.url);\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        return new Response(null, {\n            status: 204\n        });\n    }\n    const allowBatching = opts.allowBatching ?? opts.batching?.enabled ?? true;\n    const allowMethodOverride = (opts.allowMethodOverride ?? false) && req.method === 'POST';\n    const infoTuple = run(()=>{\n        try {\n            return [\n                undefined,\n                getRequestInfo({\n                    req,\n                    path: decodeURIComponent(opts.path),\n                    router,\n                    searchParams: url.searchParams,\n                    headers: opts.req.headers\n                })\n            ];\n        } catch (cause) {\n            return [\n                getTRPCErrorFromUnknown(cause),\n                undefined\n            ];\n        }\n    });\n    const ctxManager = run(()=>{\n        let result = undefined;\n        return {\n            valueOrUndefined: ()=>{\n                if (!result) {\n                    return undefined;\n                }\n                return result[1];\n            },\n            value: ()=>{\n                const [err, ctx] = result;\n                if (err) {\n                    throw err;\n                }\n                return ctx;\n            },\n            create: async (info)=>{\n                if (result) {\n                    throw new Error('This should only be called once - report a bug in tRPC');\n                }\n                try {\n                    const ctx = await opts.createContext({\n                        info\n                    });\n                    result = [\n                        undefined,\n                        ctx\n                    ];\n                } catch (cause) {\n                    result = [\n                        getTRPCErrorFromUnknown(cause),\n                        undefined\n                    ];\n                }\n            }\n        };\n    });\n    const methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n    /**\n   * @deprecated\n   */ const isStreamCall = req.headers.get('trpc-accept') === 'application/jsonl';\n    const experimentalIterablesAndDeferreds = config.iterablesAndDeferreds ?? true;\n    const experimentalSSE = config.sse?.enabled ?? true;\n    try {\n        const [infoError, info] = infoTuple;\n        if (infoError) {\n            throw infoError;\n        }\n        if (info.isBatchCall && !allowBatching) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                message: `Batching is not enabled on the server`\n            });\n        }\n        /* istanbul ignore if -- @preserve */ if (isStreamCall && !info.isBatchCall) {\n            throw new TRPCError({\n                message: `Streaming requests must be batched (you can do a batch of 1)`,\n                code: 'BAD_REQUEST'\n            });\n        }\n        await ctxManager.create(info);\n        const rpcCalls = info.calls.map(async (call)=>{\n            const proc = call.procedure;\n            try {\n                if (opts.error) {\n                    throw opts.error;\n                }\n                if (!proc) {\n                    throw new TRPCError({\n                        code: 'NOT_FOUND',\n                        message: `No procedure found on path \"${call.path}\"`\n                    });\n                }\n                if (!methodMapper[proc._def.type].includes(req.method)) {\n                    throw new TRPCError({\n                        code: 'METHOD_NOT_SUPPORTED',\n                        message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n                    });\n                }\n                if (proc._def.type === 'subscription') {\n                    /* istanbul ignore if -- @preserve */ if (info.isBatchCall) {\n                        throw new TRPCError({\n                            code: 'BAD_REQUEST',\n                            message: `Cannot batch subscription calls`\n                        });\n                    }\n                }\n                const data = await proc({\n                    path: call.path,\n                    getRawInput: call.getRawInput,\n                    ctx: ctxManager.value(),\n                    type: proc._def.type,\n                    signal: opts.req.signal\n                });\n                return [\n                    undefined,\n                    {\n                        data\n                    }\n                ];\n            } catch (cause) {\n                const error = getTRPCErrorFromUnknown(cause);\n                const input = call.result();\n                opts.onError?.({\n                    error,\n                    path: call.path,\n                    input,\n                    ctx: ctxManager.valueOrUndefined(),\n                    type: call.procedure?._def.type ?? 'unknown',\n                    req: opts.req\n                });\n                return [\n                    error,\n                    undefined\n                ];\n            }\n        });\n        // ----------- response handlers -----------\n        if (!info.isBatchCall) {\n            const [call] = info.calls;\n            const [error, result] = await rpcCalls[0];\n            switch(info.type){\n                case 'unknown':\n                case 'mutation':\n                case 'query':\n                    {\n                        // httpLink\n                        headers.set('content-type', 'application/json');\n                        if (isDataStream(result?.data)) {\n                            throw new TRPCError({\n                                code: 'UNSUPPORTED_MEDIA_TYPE',\n                                message: 'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink'\n                            });\n                        }\n                        const res = error ? {\n                            error: getErrorShape({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: info.type\n                            })\n                        } : {\n                            result: {\n                                data: result.data\n                            }\n                        };\n                        const headResponse = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: error ? [\n                                error\n                            ] : [],\n                            headers,\n                            untransformedJSON: [\n                                res\n                            ]\n                        });\n                        return new Response(JSON.stringify(transformTRPCResponse(config, res)), {\n                            status: headResponse.status,\n                            headers\n                        });\n                    }\n                case 'subscription':\n                    {\n                        // httpSubscriptionLink\n                        const iterable = run(()=>{\n                            if (error) {\n                                return errorToAsyncIterable(error);\n                            }\n                            if (!experimentalSSE) {\n                                return errorToAsyncIterable(new TRPCError({\n                                    code: 'METHOD_NOT_SUPPORTED',\n                                    message: 'Missing experimental flag \"sseSubscriptions\"'\n                                }));\n                            }\n                            if (!isObservable(result.data) && !isAsyncIterable(result.data)) {\n                                return errorToAsyncIterable(new TRPCError({\n                                    message: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n                                    code: 'INTERNAL_SERVER_ERROR'\n                                }));\n                            }\n                            const dataAsIterable = isObservable(result.data) ? observableToAsyncIterable(result.data, opts.req.signal) : result.data;\n                            return dataAsIterable;\n                        });\n                        const stream = sseStreamProducer({\n                            ...config.sse,\n                            data: iterable,\n                            serialize: (v)=>config.transformer.output.serialize(v),\n                            formatError (errorOpts) {\n                                const error = getTRPCErrorFromUnknown(errorOpts.error);\n                                const input = call?.result();\n                                const path = call?.path;\n                                const type = call?.procedure?._def.type ?? 'unknown';\n                                opts.onError?.({\n                                    error,\n                                    path,\n                                    input,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    req: opts.req,\n                                    type\n                                });\n                                const shape = getErrorShape({\n                                    config,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    error,\n                                    input,\n                                    path,\n                                    type\n                                });\n                                return shape;\n                            }\n                        });\n                        for (const [key, value] of Object.entries(sseHeaders)){\n                            headers.set(key, value);\n                        }\n                        const headResponse = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: [],\n                            headers,\n                            untransformedJSON: null\n                        });\n                        return new Response(stream, {\n                            headers,\n                            status: headResponse.status\n                        });\n                    }\n            }\n        }\n        // batch response handlers\n        if (info.accept === 'application/jsonl') {\n            // httpBatchStreamLink\n            headers.set('content-type', 'application/json');\n            headers.set('transfer-encoding', 'chunked');\n            const headResponse = initResponse({\n                ctx: ctxManager.valueOrUndefined(),\n                info,\n                responseMeta: opts.responseMeta,\n                errors: [],\n                headers,\n                untransformedJSON: null\n            });\n            const stream = jsonlStreamProducer({\n                /**\n         * Example structure for `maxDepth: 4`:\n         * {\n         *   // 1\n         *   0: {\n         *     // 2\n         *     result: {\n         *       // 3\n         *       data: // 4\n         *     }\n         *   }\n         * }\n         */ maxDepth: experimentalIterablesAndDeferreds ? 4 : 3,\n                data: rpcCalls.map(async (res)=>{\n                    const [error, result] = await res;\n                    const call = info.calls[0];\n                    if (error) {\n                        return {\n                            error: getErrorShape({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: call.procedure?._def.type ?? 'unknown'\n                            })\n                        };\n                    }\n                    /**\n           * Not very pretty, but we need to wrap nested data in promises\n           * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n           */ const iterable = isObservable(result.data) ? observableToAsyncIterable(result.data, opts.req.signal) : Promise.resolve(result.data);\n                    return {\n                        result: Promise.resolve({\n                            data: iterable\n                        })\n                    };\n                }),\n                serialize: config.transformer.output.serialize,\n                onError: (cause)=>{\n                    opts.onError?.({\n                        error: getTRPCErrorFromUnknown(cause),\n                        path: undefined,\n                        input: undefined,\n                        ctx: ctxManager.valueOrUndefined(),\n                        req: opts.req,\n                        type: info?.type ?? 'unknown'\n                    });\n                },\n                formatError (errorOpts) {\n                    const call = info?.calls[errorOpts.path[0]];\n                    const error = getTRPCErrorFromUnknown(errorOpts.error);\n                    const input = call?.result();\n                    const path = call?.path;\n                    const type = call?.procedure?._def.type ?? 'unknown';\n                    // no need to call `onError` here as it will be propagated through the stream itself\n                    const shape = getErrorShape({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input,\n                        path,\n                        type\n                    });\n                    return shape;\n                }\n            });\n            return new Response(stream, {\n                headers,\n                status: headResponse.status\n            });\n        }\n        // httpBatchLink\n        /**\n     * Non-streaming response:\n     * - await all responses in parallel, blocking on the slowest one\n     * - create headers with known response body\n     * - return a complete HTTPResponse\n     */ headers.set('content-type', 'application/json');\n        const results = (await Promise.all(rpcCalls)).map((res)=>{\n            const [error, result] = res;\n            if (error) {\n                return res;\n            }\n            if (isDataStream(result.data)) {\n                return [\n                    new TRPCError({\n                        code: 'UNSUPPORTED_MEDIA_TYPE',\n                        message: 'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink'\n                    }),\n                    undefined\n                ];\n            }\n            return res;\n        });\n        const resultAsRPCResponse = results.map(([error, result], index)=>{\n            const call = info.calls[index];\n            if (error) {\n                return {\n                    error: getErrorShape({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input: call.result(),\n                        path: call.path,\n                        type: call.procedure?._def.type ?? 'unknown'\n                    })\n                };\n            }\n            return {\n                result: {\n                    data: result.data\n                }\n            };\n        });\n        const errors = results.map(([error])=>error).filter(Boolean);\n        const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON: resultAsRPCResponse,\n            errors,\n            headers\n        });\n        return new Response(JSON.stringify(transformTRPCResponse(config, resultAsRPCResponse)), {\n            status: headResponse.status,\n            headers\n        });\n    } catch (cause) {\n        const [_infoError, info] = infoTuple;\n        const ctx = ctxManager.valueOrUndefined();\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - `router._def._config.transformer.output.serialize()` throws\n        // - post body is too large\n        // - input deserialization fails\n        // - `errorFormatter` return value is malformed\n        const { error, untransformedJSON, body } = caughtErrorToData(cause, {\n            opts,\n            ctx: ctxManager.valueOrUndefined(),\n            type: info?.type ?? 'unknown'\n        });\n        const headResponse = initResponse({\n            ctx,\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON,\n            errors: [\n                error\n            ],\n            headers\n        });\n        return new Response(body, {\n            status: headResponse.status,\n            headers\n        });\n    }\n}\n\nexport { resolveResponse };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3954, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3960, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/middleware.mjs"],"sourcesContent":["import { TRPCError } from './error/TRPCError.mjs';\nimport { isObject } from './utils.mjs';\n\n/** @internal */ const middlewareMarker = 'middlewareMarker';\n/**\n * @internal\n */ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\n/**\n * Create a standalone middleware\n * @see https://trpc.io/docs/v11/server/middlewares#experimental-standalone-middlewares\n * @deprecated use `.unstable_concat()` instead\n */ const experimental_standaloneMiddleware = ()=>({\n        create: createMiddlewareFactory()\n    });\n/**\n * @internal\n * Please note, `trpc-openapi` uses this function.\n */ function createInputMiddleware(parse) {\n    const inputMiddleware = async function inputValidatorMiddleware(opts) {\n        let parsedInput;\n        const rawInput = await opts.getRawInput();\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause\n            });\n        }\n        // Multiple input parsers\n        const combinedInput = isObject(opts.input) && isObject(parsedInput) ? {\n            ...opts.input,\n            ...parsedInput\n        } : parsedInput;\n        return opts.next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = 'input';\n    return inputMiddleware;\n}\n/**\n * @internal\n */ function createOutputMiddleware(parse) {\n    const outputMiddleware = async function outputValidatorMiddleware({ next }) {\n        const result = await next();\n        if (!result.ok) {\n            // pass through failures without validating\n            return result;\n        }\n        try {\n            const data = await parse(result.data);\n            return {\n                ...result,\n                data\n            };\n        } catch (cause) {\n            throw new TRPCError({\n                message: 'Output validation failed',\n                code: 'INTERNAL_SERVER_ERROR',\n                cause\n            });\n        }\n    };\n    outputMiddleware._type = 'output';\n    return outputMiddleware;\n}\n\nexport { createInputMiddleware, createMiddlewareFactory, createOutputMiddleware, experimental_standaloneMiddleware, middlewareMarker };\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AAEA,cAAc,GAAG,MAAM,mBAAmB;AAC1C;;CAEC,GAAG,SAAS;IACT,SAAS,sBAAsB,WAAW;QACtC,OAAO;YACH,cAAc;YACd,eAAe,qBAAqB;gBAChC,MAAM,kBAAkB,kBAAkB,wBAAwB,sBAAsB,YAAY,GAAG;oBACnG;iBACH;gBACD,OAAO,sBAAsB;uBACtB;uBACA;iBACN;YACL;QACJ;IACJ;IACA,SAAS,iBAAiB,EAAE;QACxB,OAAO,sBAAsB;YACzB;SACH;IACL;IACA,OAAO;AACX;AACA;;;;CAIC,GAAG,MAAM,oCAAoC,IAAI,CAAC;QAC3C,QAAQ;IACZ,CAAC;AACL;;;CAGC,GAAG,SAAS,sBAAsB,KAAK;IACpC,MAAM,kBAAkB,eAAe,yBAAyB,IAAI;QAChE,IAAI;QACJ,MAAM,WAAW,MAAM,KAAK,WAAW;QACvC,IAAI;YACA,cAAc,MAAM,MAAM;QAC9B,EAAE,OAAO,OAAO;YACZ,MAAM,IAAI,sMAAA,CAAA,YAAS,CAAC;gBAChB,MAAM;gBACN;YACJ;QACJ;QACA,yBAAyB;QACzB,MAAM,gBAAgB,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,KAAK,KAAK,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,eAAe;YAClE,GAAG,KAAK,KAAK;YACb,GAAG,WAAW;QAClB,IAAI;QACJ,OAAO,KAAK,IAAI,CAAC;YACb,OAAO;QACX;IACJ;IACA,gBAAgB,KAAK,GAAG;IACxB,OAAO;AACX;AACA;;CAEC,GAAG,SAAS,uBAAuB,KAAK;IACrC,MAAM,mBAAmB,eAAe,0BAA0B,EAAE,IAAI,EAAE;QACtE,MAAM,SAAS,MAAM;QACrB,IAAI,CAAC,OAAO,EAAE,EAAE;YACZ,2CAA2C;YAC3C,OAAO;QACX;QACA,IAAI;YACA,MAAM,OAAO,MAAM,MAAM,OAAO,IAAI;YACpC,OAAO;gBACH,GAAG,MAAM;gBACT;YACJ;QACJ,EAAE,OAAO,OAAO;YACZ,MAAM,IAAI,sMAAA,CAAA,YAAS,CAAC;gBAChB,SAAS;gBACT,MAAM;gBACN;YACJ;QACJ;IACJ;IACA,iBAAiB,KAAK,GAAG;IACzB,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 4057, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4063, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/parser.mjs"],"sourcesContent":["// zod / typeschema\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function' && typeof parser.assert === 'function') {\n        // ParserArkTypeEsque - arktype schemas shouldn't be called as a function because they return a union type instead of throwing\n        return parser.assert.bind(parser);\n    }\n    if (typeof parser === 'function') {\n        // ParserValibotEsque (>= v0.31.0)\n        // ParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ParserZodEsque\n        // ParserValibotEsque (< v0.13.0)\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    if (typeof parser.assert === 'function') {\n        // ParserScaleEsque\n        return (value)=>{\n            parser.assert(value);\n            return value;\n        };\n    }\n    throw new Error('Could not find a validator fn');\n}\n\nexport { getParseFn };\n"],"names":[],"mappings":"AAAA,mBAAmB;;;;AACnB,SAAS,WAAW,eAAe;IAC/B,MAAM,SAAS;IACf,IAAI,OAAO,WAAW,cAAc,OAAO,OAAO,MAAM,KAAK,YAAY;QACrE,8HAA8H;QAC9H,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC;IAC9B;IACA,IAAI,OAAO,WAAW,YAAY;QAC9B,kCAAkC;QAClC,6BAA6B;QAC7B,OAAO;IACX;IACA,IAAI,OAAO,OAAO,UAAU,KAAK,YAAY;QACzC,iBAAiB;QACjB,OAAO,OAAO,UAAU,CAAC,IAAI,CAAC;IAClC;IACA,IAAI,OAAO,OAAO,KAAK,KAAK,YAAY;QACpC,iBAAiB;QACjB,iCAAiC;QACjC,OAAO,OAAO,KAAK,CAAC,IAAI,CAAC;IAC7B;IACA,IAAI,OAAO,OAAO,YAAY,KAAK,YAAY;QAC3C,iBAAiB;QACjB,OAAO,OAAO,YAAY,CAAC,IAAI,CAAC;IACpC;IACA,IAAI,OAAO,OAAO,MAAM,KAAK,YAAY;QACrC,yBAAyB;QACzB,OAAO,OAAO,MAAM,CAAC,IAAI,CAAC;IAC9B;IACA,IAAI,OAAO,OAAO,MAAM,KAAK,YAAY;QACrC,mBAAmB;QACnB,OAAO,CAAC;YACJ,OAAO,MAAM,CAAC;YACd,OAAO;QACX;IACJ;IACA,MAAM,IAAI,MAAM;AACpB","ignoreList":[0]}},
    {"offset": {"line": 4105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4111, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/procedureBuilder.mjs"],"sourcesContent":["import { TRPCError, getTRPCErrorFromUnknown } from './error/TRPCError.mjs';\nimport { createInputMiddleware, createOutputMiddleware, middlewareMarker } from './middleware.mjs';\nimport { getParseFn } from './parser.mjs';\nimport { mergeWithoutOverrides } from './utils.mjs';\n\nfunction createNewBuilder(def1, def2) {\n    const { middlewares = [], inputs, meta, ...rest } = def2;\n    // TODO: maybe have a fn here to warn about calls\n    return createBuilder({\n        ...mergeWithoutOverrides(def1, rest),\n        inputs: [\n            ...def1.inputs,\n            ...inputs ?? []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? {\n            ...def1.meta,\n            ...meta\n        } : meta ?? def1.meta\n    });\n}\nfunction createBuilder(initDef = {}) {\n    const _def = {\n        procedure: true,\n        inputs: [],\n        middlewares: [],\n        ...initDef\n    };\n    const builder = {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parser = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parser)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta\n            });\n        },\n        use (middlewareBuilderOrFn) {\n            // Distinguish between a middleware builder and a middleware function\n            const middlewares = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares: middlewares\n            });\n        },\n        unstable_concat (builder) {\n            return createNewBuilder(_def, builder._def);\n        },\n        query (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'query'\n            }, resolver);\n        },\n        mutation (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'mutation'\n            }, resolver);\n        },\n        subscription (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'subscription'\n            }, resolver);\n        },\n        experimental_caller (caller) {\n            return createNewBuilder(_def, {\n                caller\n            });\n        }\n    };\n    return builder;\n}\nfunction createResolver(_defIn, resolver) {\n    const finalBuilder = createNewBuilder(_defIn, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    const _def = {\n        ...finalBuilder._def,\n        type: _defIn.type,\n        experimental_caller: Boolean(finalBuilder._def.caller),\n        meta: finalBuilder._def.meta,\n        $types: null\n    };\n    const invoke = createProcedureCaller(finalBuilder._def);\n    const callerOverride = finalBuilder._def.caller;\n    if (!callerOverride) {\n        return invoke;\n    }\n    const callerWrapper = async (...args)=>{\n        return await callerOverride({\n            args,\n            invoke,\n            _def: _def\n        });\n    };\n    callerWrapper._def = _def;\n    return callerWrapper;\n}\nconst codeblock = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls\n`.trim();\n// run the middlewares recursively with the resolver as the last one\nasync function callRecursive(index, _def, opts) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const middleware = _def.middlewares[index];\n        const result = await middleware({\n            ...opts,\n            meta: _def.meta,\n            input: opts.input,\n            next (_nextOpts) {\n                const nextOpts = _nextOpts;\n                return callRecursive(index + 1, _def, {\n                    ...opts,\n                    ctx: nextOpts?.ctx ? {\n                        ...opts.ctx,\n                        ...nextOpts.ctx\n                    } : opts.ctx,\n                    input: nextOpts && 'input' in nextOpts ? nextOpts.input : opts.input,\n                    getRawInput: nextOpts?.getRawInput ?? opts.getRawInput\n                });\n            }\n        });\n        return result;\n    } catch (cause) {\n        return {\n            ok: false,\n            error: getTRPCErrorFromUnknown(cause),\n            marker: middlewareMarker\n        };\n    }\n}\nfunction createProcedureCaller(_def) {\n    async function procedure(opts) {\n        // is direct server-side call\n        if (!opts || !('getRawInput' in opts)) {\n            throw new Error(codeblock);\n        }\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive(0, _def, opts);\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    }\n    procedure._def = _def;\n    // FIXME typecast shouldn't be needed - fixittt\n    return procedure;\n}\n\nexport { createBuilder };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4310, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4316, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/rootConfig.mjs"],"sourcesContent":["/**\n * The default check to see if we're in a server\n */ const isServerDefault = typeof window === 'undefined' || 'Deno' in window || // eslint-disable-next-line @typescript-eslint/dot-notation\nglobalThis.process?.env?.['NODE_ENV'] === 'test' || !!globalThis.process?.env?.['JEST_WORKER_ID'] || !!globalThis.process?.env?.['VITEST_WORKER_ID'];\n\nexport { isServerDefault };\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAAG,MAAM,kBAAkB,OAAO,WAAW,eAAe,UAAU,UAAU,2DAA2D;AAC5I,WAAW,OAAO,EAAE,KAAK,CAAC,WAAW,KAAK,UAAU,CAAC,CAAC,WAAW,OAAO,EAAE,KAAK,CAAC,iBAAiB,IAAI,CAAC,CAAC,WAAW,OAAO,EAAE,KAAK,CAAC,mBAAmB","ignoreList":[0]}},
    {"offset": {"line": 4324, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4330, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/router.mjs"],"sourcesContent":["import { createRecursiveProxy } from './createProxy.mjs';\nimport { defaultFormatter } from './error/formatter.mjs';\nimport { TRPCError, getTRPCErrorFromUnknown } from './error/TRPCError.mjs';\nimport { defaultTransformer } from './transformer.mjs';\nimport { mergeWithoutOverrides, omitPrototype, isFunction } from './utils.mjs';\n\nfunction isRouter(procedureOrRouter) {\n    return procedureOrRouter._def && 'router' in procedureOrRouter._def;\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n * Reserved words that can't be used as router or procedure names\n */ const reservedWords = [\n    /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */ 'then',\n    /**\n   * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`\n   */ 'call',\n    'apply'\n];\n/**\n * @internal\n */ function createRouterFactory(config) {\n    function createRouterInner(input) {\n        const reservedWordsUsed = new Set(Object.keys(input).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) {\n            throw new Error('Reserved words used in `router({})` call: ' + Array.from(reservedWordsUsed).join(', '));\n        }\n        const procedures = omitPrototype({});\n        function step(from, path = []) {\n            const aggregate = omitPrototype({});\n            for (const [key, item] of Object.entries(from ?? {})){\n                if (isRouter(item)) {\n                    aggregate[key] = step(item._def.record, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                if (!isProcedure(item)) {\n                    // RouterRecord\n                    aggregate[key] = step(item, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                const newPath = [\n                    ...path,\n                    key\n                ].join('.');\n                if (procedures[newPath]) {\n                    throw new Error(`Duplicate key: ${newPath}`);\n                }\n                procedures[newPath] = item;\n                aggregate[key] = item;\n            }\n            return aggregate;\n        }\n        const record = step(input);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures,\n            ...emptyRouter,\n            record\n        };\n        return {\n            ...record,\n            _def,\n            createCaller: createCallerFactory()({\n                _def\n            })\n        };\n    }\n    return createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n    return typeof procedureOrRouter === 'function';\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type, path } = opts;\n    const proc = opts.procedures[path];\n    if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    /* istanbul ignore if -- @preserve */ if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === 'subscription') {\n        throw new TRPCError({\n            code: 'METHOD_NOT_SUPPORTED',\n            message: `Method override is not supported for subscriptions`\n        });\n    }\n    return proc(opts);\n}\nfunction createCallerFactory() {\n    return function createCallerInner(router) {\n        const _def = router._def;\n        return function createCaller(ctxOrCallback, opts) {\n            return createRecursiveProxy(async ({ path, args })=>{\n                const fullPath = path.join('.');\n                if (path.length === 1 && path[0] === '_def') {\n                    return _def;\n                }\n                const procedure = _def.procedures[fullPath];\n                let ctx = undefined;\n                try {\n                    ctx = isFunction(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n                    return await procedure({\n                        path: fullPath,\n                        getRawInput: async ()=>args[0],\n                        ctx,\n                        type: procedure._def.type,\n                        signal: opts?.signal\n                    });\n                } catch (cause) {\n                    opts?.onError?.({\n                        ctx,\n                        error: getTRPCErrorFromUnknown(cause),\n                        input: args[0],\n                        path: fullPath,\n                        type: procedure._def.type\n                    });\n                    throw cause;\n                }\n            });\n        };\n    };\n}\nfunction mergeRouters(...routerList) {\n    const record = mergeWithoutOverrides({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {\n                throw new Error('You seem to have several error formatters');\n            }\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) {\n                throw new Error('You seem to have several transformers');\n            }\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.every((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.every((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.every((r)=>r._def._config.isServer),\n        $types: routerList[0]?._def._config.$types\n    })(record);\n    return router;\n}\n\nexport { callProcedure, createCallerFactory, createRouterFactory, mergeRouters };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4521, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/initTRPC.mjs"],"sourcesContent":["import { defaultFormatter } from './error/formatter.mjs';\nimport { createMiddlewareFactory } from './middleware.mjs';\nimport { createBuilder } from './procedureBuilder.mjs';\nimport { isServerDefault } from './rootConfig.mjs';\nimport { createRouterFactory, mergeRouters, createCallerFactory } from './router.mjs';\nimport { getDataTransformer, defaultTransformer } from './transformer.mjs';\n\nclass TRPCBuilder {\n    /**\n   * Add a context shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/server/context\n   */ context() {\n        return new TRPCBuilder();\n    }\n    /**\n   * Add a meta shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/quickstart\n   */ meta() {\n        return new TRPCBuilder();\n    }\n    /**\n   * Create the root object\n   * @see https://trpc.io/docs/v11/server/routers#initialize-trpc\n   */ create(opts) {\n        const config = {\n            ...opts,\n            transformer: getDataTransformer(opts?.transformer ?? defaultTransformer),\n            isDev: opts?.isDev ?? // eslint-disable-next-line @typescript-eslint/dot-notation\n            globalThis.process?.env['NODE_ENV'] !== 'production',\n            allowOutsideOfServer: opts?.allowOutsideOfServer ?? false,\n            errorFormatter: opts?.errorFormatter ?? defaultFormatter,\n            isServer: opts?.isServer ?? isServerDefault,\n            /**\n       * These are just types, they can't be used at runtime\n       * @internal\n       */ $types: null\n        };\n        {\n            // Server check\n            const isServer = opts?.isServer ?? isServerDefault;\n            if (!isServer && opts?.allowOutsideOfServer !== true) {\n                throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n            }\n        }\n        return {\n            /**\n       * Your router config\n       * @internal\n       */ _config: config,\n            /**\n       * Builder object for creating procedures\n       * @see https://trpc.io/docs/v11/server/procedures\n       */ procedure: createBuilder({\n                meta: opts?.defaultMeta\n            }),\n            /**\n       * Create reusable middlewares\n       * @see https://trpc.io/docs/v11/server/middlewares\n       */ middleware: createMiddlewareFactory(),\n            /**\n       * Create a router\n       * @see https://trpc.io/docs/v11/server/routers\n       */ router: createRouterFactory(config),\n            /**\n       * Merge Routers\n       * @see https://trpc.io/docs/v11/server/merging-routers\n       */ mergeRouters,\n            /**\n       * Create a server-side caller for a router\n       * @see https://trpc.io/docs/v11/server/server-side-calls\n       */ createCallerFactory: createCallerFactory()\n        };\n    }\n}\n/**\n * Builder to initialize the tRPC root object - use this exactly once per backend\n * @see https://trpc.io/docs/v11/quickstart\n */ const initTRPC = new TRPCBuilder();\n\nexport { initTRPC };\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM;IACF;;;GAGD,GAAG,UAAU;QACR,OAAO,IAAI;IACf;IACA;;;GAGD,GAAG,OAAO;QACL,OAAO,IAAI;IACf;IACA;;;GAGD,GAAG,OAAO,IAAI,EAAE;QACX,MAAM,SAAS;YACX,GAAG,IAAI;YACP,aAAa,CAAA,GAAA,+LAAA,CAAA,qBAAkB,AAAD,EAAE,MAAM,eAAe,+LAAA,CAAA,qBAAkB;YACvE,OAAO,MAAM,SAAS,2DAA2D;YACjF,WAAW,OAAO,EAAE,GAAG,CAAC,WAAW,KAAK;YACxC,sBAAsB,MAAM,wBAAwB;YACpD,gBAAgB,MAAM,kBAAkB,sMAAA,CAAA,mBAAgB;YACxD,UAAU,MAAM,YAAY,8LAAA,CAAA,kBAAe;YAC3C;;;OAGL,GAAG,QAAQ;QACV;QACA;YACI,eAAe;YACf,MAAM,WAAW,MAAM,YAAY,8LAAA,CAAA,kBAAe;YAClD,IAAI,CAAC,YAAY,MAAM,yBAAyB,MAAM;gBAClD,MAAM,IAAI,MAAM,CAAC,gGAAgG,CAAC;YACtH;QACJ;QACA,OAAO;YACH;;;OAGL,GAAG,SAAS;YACP;;;OAGL,GAAG,WAAW,CAAA,GAAA,oMAAA,CAAA,gBAAa,AAAD,EAAE;gBACnB,MAAM,MAAM;YAChB;YACA;;;OAGL,GAAG,YAAY,CAAA,GAAA,8LAAA,CAAA,0BAAuB,AAAD;YAChC;;;OAGL,GAAG,QAAQ,CAAA,GAAA,0LAAA,CAAA,sBAAmB,AAAD,EAAE;YAC1B;;;OAGL,GAAG,cAAA,0LAAA,CAAA,eAAY;YACV;;;OAGL,GAAG,qBAAqB,CAAA,GAAA,0LAAA,CAAA,sBAAmB,AAAD;QACzC;IACJ;AACJ;AACA;;;CAGC,GAAG,MAAM,WAAW,IAAI","ignoreList":[0]}},
    {"offset": {"line": 4608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4614, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/procedure.mjs"],"sourcesContent":["const procedureTypes = [\n    'query',\n    'mutation',\n    'subscription'\n];\n\nexport { procedureTypes };\n"],"names":[],"mappings":";;;AAAA,MAAM,iBAAiB;IACnB;IACA;IACA;CACH","ignoreList":[0]}},
    {"offset": {"line": 4623, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4629, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/mudus_ujn57l5/work/Bootcamp-Shilpa/t3-crud-app/node_modules/%40trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs"],"sourcesContent":["import { procedureTypes } from '../procedure.mjs';\nimport { isObject } from '../utils.mjs';\n\n/* istanbul ignore next -- @preserve */ function assertIsObject(obj) {\n    if (!isObject(obj)) {\n        throw new Error('Not an object');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsProcedureType(obj) {\n    if (!procedureTypes.includes(obj)) {\n        throw new Error('Invalid procedure type');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsRequestId(obj) {\n    if (obj !== null && typeof obj === 'number' && isNaN(obj) && typeof obj !== 'string') {\n        throw new Error('Invalid request id');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsString(obj) {\n    if (typeof obj !== 'string') {\n        throw new Error('Invalid string');\n    }\n}\n/* istanbul ignore next -- @preserve */ function assertIsJSONRPC2OrUndefined(obj) {\n    if (typeof obj !== 'undefined' && obj !== '2.0') {\n        throw new Error('Must be JSONRPC 2.0');\n    }\n}\n/** @public */ function parseTRPCMessage(obj, transformer) {\n    assertIsObject(obj);\n    const { id, jsonrpc, method, params } = obj;\n    assertIsRequestId(id);\n    assertIsJSONRPC2OrUndefined(jsonrpc);\n    if (method === 'subscription.stop') {\n        return {\n            id,\n            jsonrpc,\n            method\n        };\n    }\n    assertIsProcedureType(method);\n    assertIsObject(params);\n    const { input: rawInput, path, lastEventId } = params;\n    assertIsString(path);\n    if (lastEventId !== undefined) {\n        assertIsString(lastEventId);\n    }\n    const input = transformer.input.deserialize(rawInput);\n    return {\n        id,\n        jsonrpc,\n        method,\n        params: {\n            input,\n            path,\n            lastEventId\n        }\n    };\n}\n\nexport { parseTRPCMessage };\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,qCAAqC,GAAG,SAAS,eAAe,GAAG;IAC/D,IAAI,CAAC,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,MAAM;QAChB,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,sBAAsB,GAAG;IACtE,IAAI,CAAC,6LAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,MAAM;QAC/B,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,kBAAkB,GAAG;IAClE,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,MAAM,QAAQ,OAAO,QAAQ,UAAU;QAClF,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,eAAe,GAAG;IAC/D,IAAI,OAAO,QAAQ,UAAU;QACzB,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,qCAAqC,GAAG,SAAS,4BAA4B,GAAG;IAC5E,IAAI,OAAO,QAAQ,eAAe,QAAQ,OAAO;QAC7C,MAAM,IAAI,MAAM;IACpB;AACJ;AACA,YAAY,GAAG,SAAS,iBAAiB,GAAG,EAAE,WAAW;IACrD,eAAe;IACf,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG;IACxC,kBAAkB;IAClB,4BAA4B;IAC5B,IAAI,WAAW,qBAAqB;QAChC,OAAO;YACH;YACA;YACA;QACJ;IACJ;IACA,sBAAsB;IACtB,eAAe;IACf,MAAM,EAAE,OAAO,QAAQ,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG;IAC/C,eAAe;IACf,IAAI,gBAAgB,WAAW;QAC3B,eAAe;IACnB;IACA,MAAM,QAAQ,YAAY,KAAK,CAAC,WAAW,CAAC;IAC5C,OAAO;QACH;QACA;QACA;QACA,QAAQ;YACJ;YACA;YACA;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4693, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4699, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 4727, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4768, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 4774, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}